import { A as Account } from '../Ed25519Account-3zbpSq0y.mjs';
import { AccountAddress } from '../core/accountAddress.mjs';
import { HexInput, SigningScheme } from '../types/index.mjs';
import { AccountAuthenticatorMultiAuthKey } from '../transactions/authenticator/account.mjs';
import { AnyRawTransaction } from '../transactions/types.mjs';
import { MultiAuthKeySignature, MultiAuthKeyPublicKey } from '../core/crypto/multiAuthKey.mjs';
import '../core/crypto/ed25519.mjs';
import '../bcs/deserializer.mjs';
import '../bcs/serializer.mjs';
import '../core/hex.mjs';
import '../core/common.mjs';
import '../authenticationKey-D6R4BM6s.mjs';
import '../core/crypto/signature.mjs';
import '../core/crypto/privateKey.mjs';
import '../core/crypto/singleKey.mjs';
import '../transactions/instances/transactionArgument.mjs';
import '../utils/apiEndpoints.mjs';
import '../types/indexer.mjs';
import '../types/generated/operations.mjs';
import '../types/generated/types.mjs';
import '../core/crypto/multiEd25519.mjs';
import '../core/crypto/multiKey.mjs';
import '../core/crypto/bls12381.mjs';
import '../api/endlessConfig.mjs';
import '../utils/const.mjs';
import '../bcs/serializable/moveStructs.mjs';
import '../bcs/serializable/movePrimitives.mjs';
import '../bcs/serializable/fixedBytes.mjs';
import '../transactions/instances/rawTransaction.mjs';
import '../transactions/instances/chainId.mjs';
import '../transactions/instances/transactionPayload.mjs';
import '../transactions/instances/identifier.mjs';
import '../transactions/instances/moduleId.mjs';
import '../transactions/typeTag/index.mjs';
import '../transactions/instances/simpleTransaction.mjs';
import '../transactions/instances/multiAgentTransaction.mjs';

interface VerifyMultiAuthKeySignatureArgs {
    message: HexInput;
    signature: MultiAuthKeySignature;
}
/**
 * Signer implementation for the MultiKey authentication scheme.
 *
 * This accounts to use a M of N signing scheme. M and N are specified in the {@link MultiKey}
 * It signs messages via the array of M number of Accounts that individually correspond to a public key in the {@link MultiKey}.
 *
 * Note: Generating a signer instance does not create the account on-chain.
 */
declare class MultiAuthKeyAccount implements Account {
    readonly publicKey: MultiAuthKeyPublicKey;
    /**
     * Account address associated with the account
     */
    readonly accountAddress: AccountAddress;
    /**
     * Signing scheme used to sign transactions
     */
    readonly signingScheme: SigningScheme;
    /**
     * The signers used to sign messages.  These signers should correspond to public keys in the
     * MultiKeyAccount's public key.  The number of signers should be equal or greater
     * than this.publicKey.signaturesRequired
     */
    readonly signers: Account[];
    constructor(args: {
        sender: AccountAddress;
        signers: Account[];
    });
    static isMultiKeySigner(account: Account): account is MultiAuthKeyAccount;
    /**
     * Sign a message using the account's signers.
     * @param message the signing message, as binary input
     * @return the AccountAuthenticator containing the signature, together with the account's public key
     */
    signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiAuthKey;
    /**
     * Sign a transaction using the account's signers.
     * @param transaction the raw transaction
     * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key
     */
    signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiAuthKey;
    /**
    * Waits for any proofs on any KeylessAccount signers to be fetched. If the proof is fetched a syncronously, call this
    * to ensure signing with the KeylessAccount does not fail as the proof must be ready.
    * @return
    */
    waitForProofFetch(): Promise<void>;
    /**
     * Sign the given message using the MultiKeyAccount's signers
     * @param message in HexInput format
     * @returns MultiKeySignature
     */
    sign(data: HexInput): MultiAuthKeySignature;
    /**
     * Sign the given transaction using the MultiKeyAccount's signers
     * @param transaction the transaction to be signed
     * @returns MultiKeySignature
     */
    signTransaction(transaction: AnyRawTransaction): MultiAuthKeySignature;
    /**
     * Verify the given message and signature with the public key.
     *
     * @param args.message raw message data in HexInput format
     * @param args.signatures signed message MultiKeySignature
     * @returns boolean
     */
    verifySignature(args: VerifyMultiAuthKeySignatureArgs): boolean;
}

export { MultiAuthKeyAccount, type VerifyMultiAuthKeySignatureArgs };
