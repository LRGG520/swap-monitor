import{a as l}from"./chunk-MUXEJCU4.mjs";import{a as m}from"./chunk-E32QME53.mjs";import{c as g}from"./chunk-YPRVBJBD.mjs";import{t as p}from"./chunk-YO7VNMQZ.mjs";import{b as N}from"./chunk-R7AH4Q5E.mjs";var E=["A name must be between 3 and 63 characters long,","and can only contain lowercase a-z, 0-9, and hyphens.","A name may not start or end with a hyphen."].join(" ");function T(e){return!(!e||e.length<3||e.length>63||!/^[a-z\d][a-z\d-]{1,61}[a-z\d]$/.test(e))}function c(e){let[n,t,...o]=e.replace(/\.apt$/,"").split(".");if(o.length>0)throw new Error(`${e} is invalid. A name can only have two parts, a domain and a subdomain separated by a "."`);if(!T(n))throw new Error(`${n} is not valid. ${E}`);if(t&&!T(t))throw new Error(`${t} is not valid. ${E}`);return{domainName:t||n,subdomainName:t?n:void 0}}var U="0x37368b46ce665362562c6d1d4ec01a08c8644c488690df5a17e13ba163e20221",G="0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82",P={testnet:"0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c",mainnet:"0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c",local:G,custom:null,devnet:null};function d(e){let n=P[e.network];if(!n)throw new Error(`The ANS contract is not deployed to ${e.network}`);return n}var b=e=>{if(e&&typeof e=="object"&&"vec"in e&&Array.isArray(e.vec))return e.vec[0]};async function V(e){let{endlessConfig:n,name:t}=e,o=d(n),{domainName:s,subdomainName:r}=c(t),i=await l({endlessConfig:n,payload:{function:`${o}::router::get_owner_addr`,functionArguments:[s,r]}}),a=b(i[0]);return a?N.from(a):void 0}async function j(e){let{endlessConfig:n,expiration:t,name:o,sender:s,targetAddress:r,toAddress:i,options:a,transferable:u}=e,f=d(n),{domainName:y,subdomainName:w}=c(o),C=t.policy==="subdomain:independent"||t.policy==="subdomain:follow-domain";if(w&&!C)throw new Error("Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'");if(C&&!w)throw new Error(`Policy is set to ${t.policy} but no subdomain was provided`);if(t.policy==="domain"){let h=t.years??1;if(h!==1)throw new Error("For now, names can only be registered for 1 year at a time");let D=h*31536e3;return await m({endlessConfig:n,sender:s.accountAddress.toString(),data:{function:`${f}::router::register_domain`,functionArguments:[y,D,r,i]},options:a})}if(!w)throw new Error(`${t.policy} requires a subdomain to be provided.`);let _=await I({endlessConfig:n,name:y});if(!_)throw new Error("The domain does not exist");let S=t.policy==="subdomain:independent"?t.expirationDate:_;if(S>_)throw new Error("The subdomain expiration time cannot be greater than the domain expiration time");return await m({endlessConfig:n,sender:s.accountAddress.toString(),data:{function:`${f}::router::register_subdomain`,functionArguments:[y,w,Math.round(S/1e3),t.policy==="subdomain:follow-domain"?1:0,!!u,r,i]},options:a})}async function I(e){let{endlessConfig:n,name:t}=e,o=d(n),{domainName:s,subdomainName:r}=c(t);try{let i=await l({endlessConfig:n,payload:{function:`${o}::router::get_expiration`,functionArguments:[s,r]}});return Number(i[0])*1e3}catch{return}}async function W(e){let{endlessConfig:n,address:t}=e,o=d(n),s=await l({endlessConfig:n,payload:{function:`${o}::router::get_primary_name`,functionArguments:[N.from(t).toString()]}}),r=b(s[1]),i=b(s[0]);if(r)return[i,r].filter(Boolean).join(".")}async function Y(e){let{endlessConfig:n,sender:t,name:o,options:s}=e,r=d(n);if(!o)return await m({endlessConfig:n,sender:t.accountAddress.toString(),data:{function:`${r}::router::clear_primary_name`,functionArguments:[]},options:s});let{domainName:i,subdomainName:a}=c(o);return await m({endlessConfig:n,sender:t.accountAddress.toString(),data:{function:`${r}::router::set_primary_name`,functionArguments:[i,a]},options:s})}async function F(e){let{endlessConfig:n,name:t}=e,o=d(n),{domainName:s,subdomainName:r}=c(t),i=await l({endlessConfig:n,payload:{function:`${o}::router::get_target_addr`,functionArguments:[s,r]}}),a=b(i[0]);return a?N.from(a):void 0}async function K(e){let{endlessConfig:n,sender:t,name:o,address:s,options:r}=e,i=d(n),{domainName:a,subdomainName:u}=c(o);return await m({endlessConfig:n,sender:t.accountAddress.toString(),data:{function:`${i}::router::set_target_addr`,functionArguments:[a,u,s]},options:r})}async function H(e){let{endlessConfig:n,name:t}=e,{domainName:o,subdomainName:s=""}=c(t),a=(await g({endlessConfig:n,query:{query:p,variables:{where_condition:{domain:{_eq:o},subdomain:{_eq:s},is_active:{_eq:!0}},limit:1}},originMethod:"getName"})).current_endless_names[0];return a&&(a=A(a)),a}async function J(e){let{endlessConfig:n,options:t,accountAddress:o}=e,s=await x({endlessConfig:n});return(await g({endlessConfig:n,originMethod:"getAccountNames",query:{query:p,variables:{limit:t?.limit,offset:t?.offset,order_by:t?.orderBy,where_condition:{...e.options?.where??{},owner_address:{_eq:o.toString()},expiration_timestamp:{_gte:s}}}}})).current_endless_names.map(A)}async function X(e){let{endlessConfig:n,options:t,accountAddress:o}=e,s=await x({endlessConfig:n});return(await g({endlessConfig:n,originMethod:"getAccountDomains",query:{query:p,variables:{limit:t?.limit,offset:t?.offset,order_by:t?.orderBy,where_condition:{...e.options?.where??{},owner_address:{_eq:o.toString()},expiration_timestamp:{_gte:s},subdomain:{_eq:""}}}}})).current_endless_names.map(A)}async function Z(e){let{endlessConfig:n,options:t,accountAddress:o}=e,s=await x({endlessConfig:n});return(await g({endlessConfig:n,originMethod:"getAccountSubdomains",query:{query:p,variables:{limit:t?.limit,offset:t?.offset,order_by:t?.orderBy,where_condition:{...e.options?.where??{},owner_address:{_eq:o.toString()},expiration_timestamp:{_gte:s},subdomain:{_neq:""}}}}})).current_endless_names.map(A)}async function ee(e){let{endlessConfig:n,options:t,domain:o}=e;return(await g({endlessConfig:n,originMethod:"getDomainSubdomains",query:{query:p,variables:{limit:t?.limit,offset:t?.offset,order_by:t?.orderBy,where_condition:{...e.options?.where??{},domain:{_eq:o},subdomain:{_neq:""},is_active:{_eq:!0}}}}})).current_endless_names.map(A)}async function x(e){let{endlessConfig:n}=e,t=d(n),[o]=await l({endlessConfig:n,payload:{function:`${t}::config::reregistration_grace_sec`,functionArguments:[]}}),s=o/60/60/24,r=()=>new Date;return new Date(r().setDate(r().getDate()-s)).toISOString()}async function ne(e){let{endlessConfig:n,sender:t,name:o,years:s=1,options:r}=e,i=d(n),a=s*31536e3,{domainName:u,subdomainName:f}=c(o);if(f)throw new Error("Subdomains cannot be renewed");if(s!==1)throw new Error("Currently, only 1 year renewals are supported");return await m({endlessConfig:n,sender:t.accountAddress.toString(),data:{function:`${i}::router::renew_domain`,functionArguments:[u,a]},options:r})}function A(e){return{...e,expiration_timestamp:new Date(e.expiration_timestamp).getTime()}}export{E as a,T as b,c,U as d,G as e,d as f,V as g,j as h,I as i,W as j,Y as k,F as l,K as m,H as n,J as o,X as p,Z as q,ee as r,ne as s};
//# sourceMappingURL=chunk-4G7OBCCL.mjs.map