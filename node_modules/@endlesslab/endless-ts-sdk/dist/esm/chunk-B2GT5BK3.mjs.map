{"version":3,"sources":["../../src/api/account.ts"],"sourcesContent":["// Copyright © Endless\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account as AccountModule } from \"../account\";\nimport { AccountAddress, PrivateKey, AccountAddressInput } from \"../core\";\nimport {\n  AccountData,\n  AnyNumber,\n  GetAccountsCoinBalanceResponse,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedObjectsResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n  PaginationArgsOfIndexer,\n  GetCreatedCoinDataResponse,\n} from \"../types\";\nimport {\n  deriveAccountFromPrivateKey,\n  getAccountCoinAmount,\n  getAccountsCoinBalance,\n  getAccountCoinsCount,\n  getAccountCoinsData,\n  getAccountCollectionsWithOwnedTokens,\n  getAccountOwnedObjects,\n  getAccountOwnedTokens,\n  getAccountOwnedTokensFromCollectionAddress,\n  getAccountTokensCount,\n  getAccountTransactionsCount,\n  getInfo,\n  getModule,\n  getModules,\n  getResource,\n  getResources,\n  getTransactions,\n  lookupOriginalAccountAddress,\n  getCoinsDataCreatedBy,\n} from \"../internal/account\";\nimport {\n  // ENDLESS_COIN,\n  ENDLESS_COIN_ID,\n  ProcessorType,\n} from \"../utils/const\";\nimport { EndlessConfig } from \"./endlessConfig\";\nimport { waitForIndexerOnVersion } from \"./utils\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\n\n/**\n * A class to query all `Account` related queries on Endless.\n */\nexport class Account {\n  constructor(readonly config: EndlessConfig) { }\n\n  /**\n   * Queries the current state for an Endless account given its account address\n   *\n   * @param args.accountAddress Endless account address\n   *\n   * @returns The account data\n   *\n   * @example An example of the returned account\n   * ```\n   * {\n   *    sequence_number: \"1\",\n   *    authentication_key: \"0x5307b5f4bc67829097a8ba9b43dba3b88261eeccd1f709d9bde240fc100fbb69\"\n   * }\n   * ```\n   */\n  async getAccountInfo(args: { accountAddress: AccountAddressInput }): Promise<AccountData> {\n    return getInfo({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for all modules in an account given an account address\n   *\n   * Note: In order to get all account modules, this function may call the API\n   * multiple times as it auto paginates.\n   *\n   * @param args.accountAddress Endless account address\n   * @param args.options.offset The number module to start returning results from\n   * @param args.options.limit The number of results to return\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @returns Account modules\n   */\n\n  async getAccountModules(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs & LedgerVersionArg;\n  }): Promise<MoveModuleBytecode[]> {\n    return getModules({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a specific account module given account address and module name\n   *\n   * @param args.accountAddress Endless account address\n   * @param args.moduleName The name of the module\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @returns Account module\n   *\n   * @example\n   * const module = await endless.getAccountModule({accountAddress:\"0x456\"})\n   * // An example of an account module response\n   * ```\n   * {\n   *    bytecode: \"0xa11ceb0b0600000006010002030206050807070f0d081c200\",\n   *    abi: { address: \"0x1\" }\n   * }\n   * ```\n   */\n  async getAccountModule(args: {\n    accountAddress: AccountAddressInput;\n    moduleName: string;\n    options?: LedgerVersionArg;\n  }): Promise<MoveModuleBytecode> {\n    return getModule({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries account transactions given an account address\n   *\n   * Note: In order to get all account transactions, this function may call the API\n   * multiple times as it auto paginates.\n   *\n   * @example\n   * const transactions = await endless.getAccountTransactions({accountAddress:\"0x456\"})\n   *\n   * @param args.accountAddress Endless account address\n   * @param args.options.offset The number transaction to start returning results from\n   * @param args.options.limit The number of results to return\n   *\n   * @returns The account transactions\n   */\n  async getAccountTransactions(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs;\n  }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all account resources given an account address\n   *\n   * Note: In order to get all account resources, this function may call the API\n   * multiple times as it auto paginates.\n   *\n   * @example\n   * const resources = await endless.getAccountResources({accountAddress:\"0x456\"})\n   *\n   * @param args.accountAddress Endless account address\n   * @param args.options.offset The number resource to start returning results from\n   * @param args.options.limit The number of results to return\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   * @returns Account resources\n   */\n  async getAccountResources(args: {\n    accountAddress: AccountAddressInput;\n    options?: PaginationArgs & LedgerVersionArg;\n  }): Promise<MoveResource[]> {\n    return getResources({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries a specific account resource given account address and resource type. Note that the default is `any` in order\n   * to allow for ease of accessing properties of the object.\n   *\n   * @type The typed output of the resource\n   * @param args.accountAddress Endless account address\n   * @param args.resourceType String representation of an on-chain Move struct type, i.e \"0x1::endless_coin::EndlessCoin\"\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @returns Account resource\n   *\n   * @example\n   * const resource = await endless.getAccountResource({accountAddress:\"0x456\"})\n   *\n   */\n  async getAccountResource<T extends {} = any>(args: {\n    accountAddress: AccountAddressInput;\n    resourceType: MoveStructId;\n    options?: LedgerVersionArg;\n  }): Promise<T> {\n    return getResource<T>({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Looks up the account address for a given authentication key\n   *\n   * This handles both if the account's authentication key has been rotated or not.\n   *\n   * @example\n   * const accountAddress = await endless.lookupOriginalAccountAddress({authenticationKey:account.accountAddress})\n   *\n   * @param args.authenticationKey The authentication key\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   * @returns Promise<AccountAddress> The accountAddress associated with the authentication key\n   */\n  async lookupOriginalAccountAddress(args: {\n    authenticationKey: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: LedgerVersionArg;\n  }): Promise<AccountAddress> {\n    return lookupOriginalAccountAddress({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the current count of tokens owned by an account\n   *\n   * @example\n   * const tokensCount = await endless.getAccountTokensCount({accountAddress:\"0x456\"})\n   *\n   * @param args.accountAddress The account address\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @returns Current count of tokens owned by the account\n   */\n  async getAccountTokensCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_TRANSACTION_PROCESSOR,\n    });\n    return getAccountTokensCount({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the account's current owned tokens.\n   *\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard param\n   *\n   * @example\n   * const accountOwnedTokens = await endless.getAccountOwnedTokens({accountAddress:\"0x456\"})\n   *\n   * @param args.accountAddress The account address we want to get the tokens for\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @param args.options.tokenStandard The NFT standard to query for\n   * @param args.options.offset The number token to start returning results from\n   * @param args.options.limit The number of results to return\n   * @param args.options.orderBy The order to sort the tokens by\n   * @returns Tokens array with the token data\n   */\n  async getAccountOwnedTokens(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n  }): Promise<GetAccountOwnedTokensQueryResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountOwnedTokens({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all current tokens of a specific collection that an account owns by the collection address\n   *\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard param\n   *\n   * @example\n   * const accountOwnedTokens = await endless.getAccountOwnedTokensFromCollectionAddress({\n   *   accountAddress:\"0x123\",\n   *   collectionAddress:\"0x456\"\n   * })\n   *\n   * @param args.accountAddress The account address we want to get the tokens for\n   * @param args.collectionAddress The address of the collection being queried\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @param args.options.tokenStandard The NFT standard to query for\n   * @param args.options.offset The number token to start returning results from\n   * @param args.options.limit The number of results to return\n   * @param args.options.orderBy The order to sort the tokens by\n   * @returns Tokens array with the token data\n   */\n  async getAccountOwnedTokensFromCollectionAddress(args: {\n    accountAddress: AccountAddressInput;\n    collectionAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n  }): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountOwnedTokensFromCollectionAddress({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries for all collections that an account currently has tokens for.\n   *\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard param\n   *\n   * @example\n   * const accountCollectionsWithOwnedTokens = await endless.getAccountCollectionsWithOwnedTokens({accountAddress:\"0x123\"})\n   *\n   * @param args.accountAddress The account address we want to get the collections for\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @param args.options.tokenStandard The NFT standard to query for\n   * @param args.options.offset The number collection to start returning results from\n   * @param args.options.limit The number of results to return\n   * @param args.options.orderBy The order to sort the tokens by\n   * @returns Collections array with the collections data\n   */\n  async getAccountCollectionsWithOwnedTokens(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n  }): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.TOKEN_V2_PROCESSOR,\n    });\n    return getAccountCollectionsWithOwnedTokens({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the current count of transactions submitted by an account\n   *\n   * @example\n   * const accountTransactionsCount = await endless.getAccountTransactionsCount({accountAddress:\"0x123\"})\n   *\n   * @param args.accountAddress The account address we want to get the total count for\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @returns Current count of transactions made by an account\n   */\n  async getAccountTransactionsCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.ACCOUNT_TRANSACTION_PROCESSOR,\n    });\n    return getAccountTransactionsCount({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries an account's coins data\n   *\n   * @example\n   * const accountCoinsData = await endless.getAccountCoinsData({accountAddress:\"0x123\"})\n   *\n   * @param args.accountAddress The account address we want to get the coins data for\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @param args.options.offset optional. The number coin to start returning results from\n   * @param args.options.limit optional. The number of results to return\n   * @param args.options.orderBy optional. The order to sort the coins by\n   * @param args.options.where optional. Filter the results by\n   * @returns Array with the coins data\n   */\n  async getAccountCoinsData(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgsOfIndexer & OrderByArg<GetAccountCoinsDataResponse> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n  }): Promise<GetAccountCoinsDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinsData({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries coins data Created by account \n   *\n   * @example\n   * const accountCoinsData = await endless.getCoinsDataCreatedBy({accountAddress:\"0x123\"})\n   *\n   * @param args.accountAddress The account address of who create the coins\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @param args.options.offset optional. The number coin to start returning results from\n   * @param args.options.limit optional. The number of results to return\n   * @param args.options.orderBy optional. The order to sort the coins by\n   * @param args.options.where optional. Filter the results by\n   * @returns Array with the coins data\n   */\n  async getCoinsDataCreatedBy(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgsOfIndexer & OrderByArg<GetAccountCoinsDataResponse> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n  }): Promise<GetCreatedCoinDataResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getCoinsDataCreatedBy({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the current count of an account's coins aggregated\n   *\n   * @example\n   * const accountCoinsCount = await endless.getAccountCoinsCount({accountAddress:\"0x123\"})\n   *\n   * @param args.accountAddress The account address we want to get the total count for\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @returns Current count of the aggregated count of all account's coins\n   */\n  async getAccountCoinsCount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinsCount({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the account's EDS amount\n   *\n   * @example\n   * const accountAPTAmount = await endless.getAccountAPTAmount({accountAddress:\"0x123\"})\n   *\n   * @param args.accountAddress The account address we want to get the total count for\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @returns Current amount of account's APT\n   */\n  // async getAccountAPTAmount(args: {\n  //   accountAddress: AccountAddressInput;\n  //   minimumLedgerVersion?: AnyNumber;\n  // }): Promise<number> {\n  //   return this.getAccountCoinAmount({ coinType: ENDLESS_COIN, ...args });\n  // }\n  async getAccountEDSAmount(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    return this.getAccountCoinAmount({ coinId: ENDLESS_COIN_ID, ...args });\n  }\n\n  /**\n   * Queries the account's coin amount by the coin type\n   *\n   * @example\n   * const accountCoinAmount = await endless.getAccountCoinAmount({accountAddress:\"0x123\", coinType:\"0x1::endless_coin::EndlessCoin\"})\n   *\n   * @param args.accountAddress The account address we want to get the total count for\n   * @param args.coinType The coin type to query\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @returns Current amount of account's coin\n   */\n  async getAccountCoinAmount(args: {\n    accountAddress: AccountAddressInput;\n    coinId: string;\n    minimumLedgerVersion?: AnyNumber;\n  }): Promise<number> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.FUNGIBLE_ASSET_PROCESSOR,\n    });\n    return getAccountCoinAmount({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries an account's owned objects\n   *\n   * @example\n   * const accountOwnedObjects = await endless.getAccountOwnedObjects({accountAddress:\"0x123\"})\n   *\n   * @param args.accountAddress The account address we want to get the objects for\n   * @param args.minimumLedgerVersion Optional ledger version to sync up to, before querying\n   * @param args.options.offset The starting position to start returning results from\n   * @param args.options.limit The number of results to return\n   * @param args.options.orderBy The order to sort the objects by\n   * @returns Objects array with the object data\n   */\n  async getAccountOwnedObjects(args: {\n    accountAddress: AccountAddressInput;\n    minimumLedgerVersion?: AnyNumber;\n    options?: PaginationArgs & OrderByArg<GetAccountOwnedObjectsResponse[0]>;\n  }): Promise<GetAccountOwnedObjectsResponse> {\n    await waitForIndexerOnVersion({\n      config: this.config,\n      minimumLedgerVersion: args.minimumLedgerVersion,\n      processorType: ProcessorType.DEFAULT,\n    });\n    return getAccountOwnedObjects({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Derives an account by providing a private key.\n   * This functions resolves the provided private key type and derives the public key from it.\n   *\n   * If the privateKey is a Secp256k1 type, it derives the account using the derived public key and\n   * auth key using the SingleKey scheme locally.\n   *\n   * If the privateKey is a ED25519 type, it looks up the authentication key on chain, and uses it to resolve\n   * whether it is a Legacy ED25519 key or a Unified ED25519 key. It then derives the account based\n   * on that.\n   *\n   * @example\n   * const account = await endless.deriveAccountFromPrivateKey({privateKey:new Ed25519PrivateKey(\"0x123\")})\n   *\n   * @param args.privateKey An account private key\n   * @returns Account type\n   */\n  async deriveAccountFromPrivateKey(args: { privateKey: PrivateKey }): Promise<AccountModule> {\n    return deriveAccountFromPrivateKey({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries an account's coins data\n   *\n   * @example\n   * const accountCoinsData = await endless.getAccountCoinsData({accountAddress:[\"0x123\"]})\n   *\n   * @param args.accountAddress The account address we want to get the coins data for\n   * @param args.coinAddress The coinAddress address we want to get the coins data for\n   * @returns Array with the coins data\n   */\n  async getAccountsCoinBalance(args: {\n    accountAddress: AccountAddressInput[];\n    coinAddress: AccountAddressInput;\n  }): Promise<GetAccountsCoinBalanceResponse> {\n    return getAccountsCoinBalance({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n}\n"],"mappings":"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","names":["Account","config","args","getInfo","getModules","getModule","getTransactions","getResources","getResource","lookupOriginalAccountAddress","waitForIndexerOnVersion","getAccountTokensCount","getAccountOwnedTokens","getAccountOwnedTokensFromCollectionAddress","getAccountCollectionsWithOwnedTokens","getAccountTransactionsCount","getAccountCoinsData","getCoinsDataCreatedBy","getAccountCoinsCount","ENDLESS_COIN_ID","getAccountCoinAmount","getAccountOwnedObjects","deriveAccountFromPrivateKey","getAccountsCoinBalance"]}