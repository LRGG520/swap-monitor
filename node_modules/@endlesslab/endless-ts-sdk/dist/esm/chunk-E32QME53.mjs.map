{"version":3,"sources":["../../src/internal/transactionSubmission.ts"],"sourcesContent":["/**\n * This file contains the underlying implementations for exposed submission API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n */\n\nimport { EndlessConfig } from \"../api/endlessConfig\";\nimport { MoveVector, U8 } from \"../bcs\";\nimport { postEndlessFullNode } from \"../client\";\nimport { Account, KeylessAccount, MultiKeyAccount } from \"../account\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { PrivateKey } from \"../core/crypto\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport { RotationProofChallenge } from \"../transactions/instances/rotationProofChallenge\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n  generateMockSignedTransactionForSimulation,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  AnyTransactionPayloadInstance,\n  EntryFunctionABI,\n  InputSimulateTransactionDataMock,\n} from \"../transactions/types\";\nimport { getInfo } from \"./account\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput, TransactionResponse } from \"../types\";\nimport { TypeTagU8, TypeTagVector, generateSigningMessageForTransaction } from \"../transactions\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\nimport { MultiAgentTransaction } from \"../transactions/instances/multiAgentTransaction\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for `generateTransaction` function.\n * When we call `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function generateTransaction(\n  args: { endlessConfig: EndlessConfig } & InputGenerateSingleSignerRawTransactionData,\n): Promise<SimpleTransaction>;\nexport async function generateTransaction(\n  args: { endlessConfig: EndlessConfig } & InputGenerateMultiAgentRawTransactionData,\n): Promise<MultiAgentTransaction>;\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a AccountAddressInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::endless_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function generateTransaction(\n  args: { endlessConfig: EndlessConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const payload = await buildTransactionPayload(args);\n  return buildRawTransaction(args, payload);\n}\n\nexport async function buildTransactionPayload(\n  args: { endlessConfig: EndlessConfig } & InputGenerateTransactionData,\n): Promise<AnyTransactionPayloadInstance> {\n  const { endlessConfig, data } = args;\n  // Merge in endlessConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  let payload: AnyTransactionPayloadInstance;\n\n  if (\"bytecode\" in data) {\n    // TODO: Add ABI checking later\n    payload = await generateTransactionPayload(data);\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      endlessConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else {\n    generateTransactionPayloadData = {\n      endlessConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n      abi: data.abi,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  }\n  return payload;\n}\n\nexport async function buildRawTransaction(\n  args: { endlessConfig: EndlessConfig } & InputGenerateTransactionData,\n  payload: AnyTransactionPayloadInstance,\n): Promise<AnyRawTransaction> {\n  const { endlessConfig, sender, options } = args;\n\n  let feePayerAddress;\n  if (isFeePayerTransactionInput(args)) {\n    feePayerAddress = AccountAddress.ZERO.toString();\n  }\n\n  if (isMultiAgentTransactionInput(args)) {\n    const { secondarySignerAddresses } = args;\n    return buildTransaction({\n      endlessConfig,\n      sender,\n      payload,\n      options,\n      secondarySignerAddresses,\n      feePayerAddress,\n    });\n  }\n\n  return buildTransaction({\n    endlessConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n}\n\nfunction isFeePayerTransactionInput(data: InputGenerateTransactionData): boolean {\n  return data.withFeePayer === true;\n}\n\nfunction isMultiAgentTransactionInput(\n  data: InputGenerateTransactionData,\n): data is InputGenerateMultiAgentRawTransactionData {\n  return \"secondarySignerAddresses\" in data;\n}\n\n/**\n * Builds a signing message that can be signed by external signers\n *\n * Note: Please prefer using `signTransaction` unless signing outside the SDK\n *\n * @param args.transaction AnyRawTransaction, as generated by `generateTransaction()`\n *\n * @return The message to be signed\n */\nexport function getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n  const { transaction } = args;\n  return generateSigningMessageForTransaction(transaction);\n}\n\n/**\n * Sign a transaction that can later be submitted to chain\n *\n * @param args.signer The signer account to sign the transaction\n * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n *\n * @return The signer AccountAuthenticator\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n  return signer.signTransactionWithAuthenticator(transaction);\n}\n\n/**\n * Simulates a transaction before singing it.\n *\n * @param args.signerPublicKey The signer public key\n * @param args.transaction The raw transaction to simulate\n * @param args.secondarySignersPublicKeys optional. For when the transaction is a multi signers transaction\n * @param args.feePayerPublicKey optional. For when the transaction is a fee payer (aka sponsored) transaction\n * @param args.options optional. A config to simulate the transaction with\n */\nexport async function simulateTransaction(\n  args: { endlessConfig: EndlessConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { endlessConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postEndlessFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    endlessConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Simulates a transaction before singing it.\n *\n * @param args.signer The signer authentication key\n * @param args.transaction The raw transaction to simulate\n * @param args.secondarySigners optional. For when the transaction is a multi signers transaction\n * @param args.feePayer optional. For when the transaction is a fee payer (aka sponsored) transaction\n * @param args.options optional. A config to simulate the transaction with\n */\nexport async function mockTransaction(\n  args: { endlessConfig: EndlessConfig } & InputSimulateTransactionDataMock,\n): Promise<Array<UserTransactionResponse>> {\n  const { endlessConfig, transaction } = args;\n\n  const signedTransaction = generateMockSignedTransactionForSimulation(transaction);\n\n  const { data } = await postEndlessFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    endlessConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit transaction to chain\n *\n * @param args.transaction A endless transaction type\n * @param args.senderAuthenticator The account authenticator of the transaction sender\n * @param args.secondarySignerAuthenticators optional. For when the transaction is a multi signers transaction\n *\n * @return PendingTransactionResponse\n */\nexport async function submitTransaction(\n  args: {\n    endlessConfig: EndlessConfig;\n  } & InputSubmitTransactionData,\n): Promise<PendingTransactionResponse> {\n  const { endlessConfig } = args;\n  const signedTransaction = generateSignedTransaction({ ...args });\n  const { data } = await postEndlessFullNode<Uint8Array, PendingTransactionResponse>({\n    endlessConfig,\n    body: signedTransaction,\n    path: \"transactions\",\n    originMethod: \"submitTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\nexport async function signAndSubmitTransaction(args: {\n  endlessConfig: EndlessConfig;\n  signer: Account;\n  transaction: AnyRawTransaction;\n}): Promise<PendingTransactionResponse> {\n  const { endlessConfig, signer, transaction } = args;\n\n  if (signer instanceof KeylessAccount || signer instanceof MultiKeyAccount) {\n    await signer.waitForProofFetch();\n  }\n\n  const authenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    endlessConfig,\n    transaction,\n    senderAuthenticator: authenticator,\n  });\n}\n\nconst packagePublishAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [TypeTagVector.u8(), new TypeTagVector(TypeTagVector.u8())],\n};\n\nexport async function publicPackageTransaction(args: {\n  endlessConfig: EndlessConfig;\n  account: AccountAddressInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { endlessConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  return generateTransaction({\n    endlessConfig,\n    sender: AccountAddress.from(account),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n      abi: packagePublishAbi,\n    },\n    options,\n  });\n}\n\nconst rotateAuthKeyAbi: EntryFunctionABI = {\n  typeParameters: [],\n  parameters: [\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    new TypeTagU8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n    TypeTagVector.u8(),\n  ],\n};\n\n/**\n * TODO: Need to refactor and move this function out of transactionSubmission\n */\nexport async function rotateAuthKey(args: {\n  endlessConfig: EndlessConfig;\n  fromAccount: Account;\n  toNewPrivateKey: PrivateKey;\n}): Promise<TransactionResponse> {\n  const { endlessConfig, fromAccount, toNewPrivateKey } = args;\n  const accountInfo = await getInfo({\n    endlessConfig,\n    accountAddress: fromAccount.accountAddress,\n  });\n\n  const newAccount = Account.fromPrivateKey({ privateKey: toNewPrivateKey, legacy: true });\n\n  const challenge = new RotationProofChallenge({\n    sequenceNumber: BigInt(accountInfo.sequence_number),\n    originator: fromAccount.accountAddress,\n    currentAuthKey: AccountAddress.from(accountInfo.authentication_key),\n    newPublicKey: newAccount.publicKey,\n  });\n\n  // Sign the challenge\n  const challengeHex = challenge.bcsToBytes();\n  const proofSignedByCurrentPrivateKey = fromAccount.sign(challengeHex);\n  const proofSignedByNewPrivateKey = newAccount.sign(challengeHex);\n\n  // Generate transaction\n  const rawTxn = await generateTransaction({\n    endlessConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key\",\n      functionArguments: [\n        new U8(fromAccount.signingScheme), // from scheme\n        MoveVector.U8(fromAccount.publicKey.toUint8Array()),\n        new U8(newAccount.signingScheme), // to scheme\n        MoveVector.U8(newAccount.publicKey.toUint8Array()),\n        MoveVector.U8(proofSignedByCurrentPrivateKey.toUint8Array()),\n        MoveVector.U8(proofSignedByNewPrivateKey.toUint8Array()),\n      ],\n      abi: rotateAuthKeyAbi,\n    },\n  });\n  return signAndSubmitTransaction({\n    endlessConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n}\n"],"mappings":"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","names":["generateTransaction","args","payload","buildTransactionPayload","buildRawTransaction","endlessConfig","data","generateTransactionPayloadData","generateTransactionPayload","sender","options","feePayerAddress","isFeePayerTransactionInput","AccountAddress","isMultiAgentTransactionInput","secondarySignerAddresses","buildTransaction","getSigningMessage","transaction","generateSigningMessageForTransaction","signTransaction","signer","simulateTransaction","signerPublicKey","secondarySignersPublicKeys","feePayerPublicKey","signedTransaction","generateSignedTransactionForSimulation","postEndlessFullNode","mockTransaction","generateMockSignedTransactionForSimulation","submitTransaction","generateSignedTransaction","signAndSubmitTransaction","KeylessAccount","MultiKeyAccount","authenticator","packagePublishAbi","TypeTagVector","publicPackageTransaction","account","metadataBytes","moduleBytecode","totalByteCode","bytecode","MoveVector","rotateAuthKeyAbi","TypeTagU8","rotateAuthKey","fromAccount","toNewPrivateKey","accountInfo","getInfo","newAccount","Account","challengeHex","RotationProofChallenge","proofSignedByCurrentPrivateKey","proofSignedByNewPrivateKey","rawTxn","U8"]}