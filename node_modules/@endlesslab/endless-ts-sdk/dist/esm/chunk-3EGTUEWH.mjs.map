{"version":3,"sources":["../../src/account/MultiAuthKeyAccount.ts"],"sourcesContent":["// Copyright © Endless\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account } from \"./Account\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport { AccountAuthenticatorMultiAuthKey } from \"../transactions/authenticator/account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { KeylessAccount } from \"./KeylessAccount\";\nimport { MultiAuthKeyPublicKey, MultiAuthKeySignature } from \"../core/crypto/multiAuthKey\";\n\nexport interface VerifyMultiAuthKeySignatureArgs {\n  message: HexInput;\n  signature: MultiAuthKeySignature;\n}\n\n/**\n * Signer implementation for the MultiKey authentication scheme.\n *\n * This accounts to use a M of N signing scheme. M and N are specified in the {@link MultiKey}\n * It signs messages via the array of M number of Accounts that individually correspond to a public key in the {@link MultiKey}.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n */\nexport class MultiAuthKeyAccount implements Account {\n\n  readonly publicKey: MultiAuthKeyPublicKey;\n\n  /**\n   * Account address associated with the account\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   */\n  readonly signingScheme: SigningScheme;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiKeyAccount's public key.  The number of signers should be equal or greater\n   * than this.publicKey.signaturesRequired\n   */\n  readonly signers: Account[];\n\n  constructor(args: { sender: AccountAddress; signers: Account[] }) {\n    const { sender, signers } = args;\n\n    this.accountAddress = sender;\n    this.signingScheme = SigningScheme.MultiAuthKey;\n    this.publicKey = new MultiAuthKeyPublicKey({ publicKeys: signers.map((signer) => signer.publicKey) });\n\n    this.signers = signers;\n  }\n\n  static isMultiKeySigner(account: Account): account is MultiAuthKeyAccount {\n    return account instanceof MultiAuthKeyAccount;\n  }\n\n  /**\n   * Sign a message using the account's signers.\n   * @param message the signing message, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiAuthKey {\n    return new AccountAuthenticatorMultiAuthKey(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's signers.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiAuthKey {\n    return new AccountAuthenticatorMultiAuthKey(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n  * Waits for any proofs on any KeylessAccount signers to be fetched. If the proof is fetched a syncronously, call this\n  * to ensure signing with the KeylessAccount does not fail as the proof must be ready.\n  * @return\n  */\n  async waitForProofFetch() {\n    const keylessSigners = this.signers.filter((signer) => signer instanceof KeylessAccount) as KeylessAccount[];\n    const promises = keylessSigners.map(async (signer) => signer.waitForProofFetch());\n    await Promise.all(promises);\n  }\n\n  /**\n   * Sign the given message using the MultiKeyAccount's signers\n   * @param message in HexInput format\n   * @returns MultiKeySignature\n   */\n  sign(data: HexInput): MultiAuthKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(data));\n    }\n    return new MultiAuthKeySignature({ signatures });\n  }\n\n  /**\n   * Sign the given transaction using the MultiKeyAccount's signers\n   * @param transaction the transaction to be signed\n   * @returns MultiKeySignature\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiAuthKeySignature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.signTransaction(transaction));\n    }\n    return new MultiAuthKeySignature({ signatures });\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args.message raw message data in HexInput format\n   * @param args.signatures signed message MultiKeySignature\n   * @returns boolean\n   */\n  verifySignature(args: VerifyMultiAuthKeySignatureArgs): boolean {\n    const { message, signature } = args;\n    if (signature.signatures.length !== this.publicKey.publicKeys.length) {\n      return false;\n    }\n    for (let i = 0; i < signature.signatures.length; i += 1) {\n      const singleSignature = signature.signatures[i];\n      const publicKey = this.publicKey.publicKeys[i];\n      if (!publicKey.verifySignature({ message, signature: singleSignature })) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"],"mappings":"kIAyBO,IAAMA,EAAN,MAAMC,CAAuC,CAqBlD,YAAYC,EAAsD,CAChE,GAAM,CAAE,OAAAC,EAAQ,QAAAC,CAAQ,EAAIF,EAE5B,KAAK,eAAiBC,EACtB,KAAK,cAAgB,EACrB,KAAK,UAAY,IAAIE,EAAsB,CAAE,WAAYD,EAAQ,IAAKE,GAAWA,EAAO,SAAS,CAAE,CAAC,EAEpG,KAAK,QAAUF,CACjB,CAEA,OAAO,iBAAiBG,EAAkD,CACxE,OAAOA,aAAmBN,CAC5B,CAOA,sBAAsBO,EAAqD,CACzE,OAAO,IAAIC,EAAiC,KAAK,UAAW,KAAK,KAAKD,CAAO,CAAC,CAChF,CAOA,iCAAiCE,EAAkE,CACjG,OAAO,IAAID,EAAiC,KAAK,UAAW,KAAK,gBAAgBC,CAAW,CAAC,CAC/F,CAOA,MAAM,mBAAoB,CAExB,IAAMC,EADiB,KAAK,QAAQ,OAAQL,GAAWA,aAAkBM,CAAc,EACvD,IAAI,MAAON,GAAWA,EAAO,kBAAkB,CAAC,EAChF,MAAM,QAAQ,IAAIK,CAAQ,CAC5B,CAOA,KAAKE,EAAuC,CAC1C,IAAMC,EAAa,CAAC,EACpB,QAAWR,KAAU,KAAK,QACxBQ,EAAW,KAAKR,EAAO,KAAKO,CAAI,CAAC,EAEnC,OAAO,IAAIE,EAAsB,CAAE,WAAAD,CAAW,CAAC,CACjD,CAOA,gBAAgBJ,EAAuD,CACrE,IAAMI,EAAa,CAAC,EACpB,QAAWR,KAAU,KAAK,QACxBQ,EAAW,KAAKR,EAAO,gBAAgBI,CAAW,CAAC,EAErD,OAAO,IAAIK,EAAsB,CAAE,WAAAD,CAAW,CAAC,CACjD,CASA,gBAAgBZ,EAAgD,CAC9D,GAAM,CAAE,QAAAM,EAAS,UAAAQ,CAAU,EAAId,EAC/B,GAAIc,EAAU,WAAW,SAAW,KAAK,UAAU,WAAW,OAC5D,MAAO,GAET,QAAS,EAAI,EAAG,EAAIA,EAAU,WAAW,OAAQ,GAAK,EAAG,CACvD,IAAMC,EAAkBD,EAAU,WAAW,CAAC,EAE9C,GAAI,CADc,KAAK,UAAU,WAAW,CAAC,EAC9B,gBAAgB,CAAE,QAAAR,EAAS,UAAWS,CAAgB,CAAC,EACpE,MAAO,EAEX,CACA,MAAO,EACT,CACF","names":["MultiAuthKeyAccount","_MultiAuthKeyAccount","args","sender","signers","MultiAuthKeyPublicKey","signer","account","message","AccountAuthenticatorMultiAuthKey","transaction","promises","KeylessAccount","data","signatures","MultiAuthKeySignature","signature","singleSignature"]}