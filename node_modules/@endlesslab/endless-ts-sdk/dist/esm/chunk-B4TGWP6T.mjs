import{d as A}from"./chunk-PSOJ2Q5V.mjs";import{d as m}from"./chunk-T2NK4HOP.mjs";import{a as b}from"./chunk-5UW2J3ZQ.mjs";import{a as f,b as y}from"./chunk-4NCTUR2D.mjs";import{i as S,j as F,k as E,m as d}from"./chunk-BVS7ECHS.mjs";import{b as w}from"./chunk-R7AH4Q5E.mjs";import{a as g}from"./chunk-2PISSJSZ.mjs";import{a as K}from"./chunk-Y3FIGVYP.mjs";import{b as P}from"./chunk-H24X6T4W.mjs";import{jwtDecode as v}from"jwt-decode";import j from"eventemitter3";var o=class o extends K{constructor(e){super();let{address:r,ephemeralKeyPair:t,uidKey:i,uidVal:a,aud:c,pepper:p,proof:n,proofFetchCallback:s,jwt:h}=e;if(this.ephemeralKeyPair=t,this.publicKey=S.create(e),this.accountAddress=r?w.from(r):this.publicKey.authKey().derivedAddress(),this.uidKey=i,this.uidVal=a,this.aud=c,this.jwt=h,this.emitter=new j,this.proofOrPromise=n,n instanceof d)this.proof=n;else{if(s===void 0)throw new Error("Must provide callback for async proof fetch");this.emitter.on("proofFetchFinish",async u=>{await s(u),this.emitter.removeAllListeners()}),this.init(n)}this.signingScheme=2;let l=P.fromHexInput(p).toUint8Array();if(l.length!==o.PEPPER_LENGTH)throw new Error(`Pepper length in bytes should be ${o.PEPPER_LENGTH}`);this.pepper=l}async init(e){try{this.proof=await e,this.emitter.emit("proofFetchFinish",{status:"Success"})}catch(r){r instanceof Error?this.emitter.emit("proofFetchFinish",{status:"Failed",error:r.toString()}):this.emitter.emit("proofFetchFinish",{status:"Failed",error:"Unknown"})}}serialize(e){if(e.serializeStr(this.jwt),e.serializeStr(this.uidKey),e.serializeFixedBytes(this.pepper),this.ephemeralKeyPair.serialize(e),this.proof===void 0)throw new Error("Connot serialize - proof undefined");this.proof.serialize(e)}static deserialize(e){let r=e.deserializeStr(),t=e.deserializeStr(),i=e.deserializeFixedBytes(31),a=b.deserialize(e),c=d.deserialize(e);return o.create({proof:c,pepper:i,uidKey:t,jwt:r,ephemeralKeyPair:a})}isExpired(){return this.ephemeralKeyPair.isExpired()}signWithAuthenticator(e){let r=new y(this.sign(e)),t=new f(this.publicKey);return new m(t,r)}signTransactionWithAuthenticator(e){let r=new y(this.signTransaction(e)),t=new f(this.publicKey);return new m(t,r)}async waitForProofFetch(){this.proofOrPromise instanceof Promise&&await this.proofOrPromise}sign(e){let{expiryDateSecs:r}=this.ephemeralKeyPair;if(this.isExpired())throw new Error("EphemeralKeyPair is expired");if(this.proof===void 0)throw new Error("Proof not defined");let t=this.ephemeralKeyPair.getPublicKey(),i=this.ephemeralKeyPair.sign(e);return new F({jwtHeader:this.jwt.split(".")[0],ephemeralCertificate:new E(this.proof,0),expiryDateSecs:r,ephemeralPublicKey:t,ephemeralSignature:i})}signTransaction(e){if(this.proof===void 0)throw new Error("Proof not found");let r=A(e);return this.sign(r)}verifySignature(e){let{message:r,signature:t}=e;return!(this.isExpired()||!this.ephemeralKeyPair.getPublicKey().verifySignature({message:r,signature:t.ephemeralSignature}))}static fromBytes(e){return o.deserialize(new g(e))}static create(e){let{address:r,proof:t,jwt:i,ephemeralKeyPair:a,pepper:c,uidKey:p="sub",proofFetchCallback:n}=e,s=v(i),h=s.iss;if(typeof s.aud!="string")throw new Error("aud was not found or an array of values");let l=s.aud,u=s[p];return new o({address:r,proof:t,ephemeralKeyPair:a,iss:h,uidKey:p,uidVal:u,aud:l,pepper:c,jwt:i,proofFetchCallback:n})}};o.PEPPER_LENGTH=31;var x=o;export{x as a};
//# sourceMappingURL=chunk-B4TGWP6T.mjs.map