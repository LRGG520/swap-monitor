import { EndlessConfig } from '../api/endlessConfig.mjs';
import { AccountAddress, AccountAddressInput } from '../core/accountAddress.mjs';
import { AnyNumber, PaginationArgs, OrderByArg, TokenStandardArg, MoveStructId } from '../types/index.mjs';
import { A as Account } from '../Ed25519Account-3zbpSq0y.mjs';
import { InputGenerateTransactionOptions } from '../transactions/types.mjs';
import { SimpleTransaction } from '../transactions/instances/simpleTransaction.mjs';
import { GetTokenDataResponse, GetCurrentTokenOwnershipResponse, GetTokenActivityResponse, GetOwnedTokensResponse, GetCollectionDataResponse } from '../types/indexer.mjs';
import '../utils/apiEndpoints.mjs';
import '../utils/const.mjs';
import '../types/generated/operations.mjs';
import '../types/generated/types.mjs';
import '../bcs/serializer.mjs';
import '../core/hex.mjs';
import '../core/common.mjs';
import '../bcs/deserializer.mjs';
import '../transactions/instances/transactionArgument.mjs';
import '../transactions/authenticator/account.mjs';
import '../core/crypto/ed25519.mjs';
import '../authenticationKey-D6R4BM6s.mjs';
import '../core/crypto/signature.mjs';
import '../core/crypto/privateKey.mjs';
import '../core/crypto/multiEd25519.mjs';
import '../core/crypto/multiKey.mjs';
import '../core/crypto/singleKey.mjs';
import '../core/crypto/bls12381.mjs';
import '../core/crypto/multiAuthKey.mjs';
import '../bcs/serializable/moveStructs.mjs';
import '../bcs/serializable/movePrimitives.mjs';
import '../bcs/serializable/fixedBytes.mjs';
import '../transactions/instances/rawTransaction.mjs';
import '../transactions/instances/chainId.mjs';
import '../transactions/instances/transactionPayload.mjs';
import '../transactions/instances/identifier.mjs';
import '../transactions/instances/moduleId.mjs';
import '../transactions/typeTag/index.mjs';
import '../transactions/instances/multiAgentTransaction.mjs';

/**
 * This file contains the underlying implementations for exposed API surface in
 * the {@link api/digitalAsset}. By moving the methods out into a separate file,
 * other namespaces and processes can access these methods without depending on the entire
 * digitalAsset namespace and without having a dependency cycle error.
 */

declare const PropertyTypeMap: {
    BOOLEAN: string;
    U8: string;
    U16: string;
    U32: string;
    U64: string;
    U128: string;
    U256: string;
    ADDRESS: string;
    STRING: string;
    ARRAY: string;
};
type PropertyType = keyof typeof PropertyTypeMap;
type PropertyValue = boolean | number | bigint | string | AccountAddress | Uint8Array;
declare function getDigitalAssetData(args: {
    endlessConfig: EndlessConfig;
    digitalAssetAddress: AccountAddressInput;
}): Promise<GetTokenDataResponse>;
declare function getCurrentDigitalAssetOwnership(args: {
    endlessConfig: EndlessConfig;
    digitalAssetAddress: AccountAddressInput;
}): Promise<GetCurrentTokenOwnershipResponse>;
declare function getOwnedDigitalAssets(args: {
    endlessConfig: EndlessConfig;
    ownerAddress: AccountAddressInput;
    options?: PaginationArgs & OrderByArg<GetTokenActivityResponse[0]>;
}): Promise<GetOwnedTokensResponse>;
declare function getDigitalAssetActivity(args: {
    endlessConfig: EndlessConfig;
    digitalAssetAddress: AccountAddressInput;
    options?: PaginationArgs & OrderByArg<GetTokenActivityResponse[0]>;
}): Promise<GetTokenActivityResponse>;
interface CreateCollectionOptions {
    maxSupply?: AnyNumber;
    mutableDescription?: boolean;
    mutableRoyalty?: boolean;
    mutableURI?: boolean;
    mutableTokenDescription?: boolean;
    mutableTokenName?: boolean;
    mutableTokenProperties?: boolean;
    mutableTokenURI?: boolean;
    tokensBurnableByCreator?: boolean;
    tokensFreezableByCreator?: boolean;
    royaltyNumerator?: number;
    royaltyDenominator?: number;
}
declare function createCollectionTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    description: string;
    name: string;
    uri: string;
    options?: InputGenerateTransactionOptions;
} & CreateCollectionOptions): Promise<SimpleTransaction>;
declare function getCollectionData(args: {
    endlessConfig: EndlessConfig;
    creatorAddress: AccountAddressInput;
    collectionName: string;
    options?: TokenStandardArg;
}): Promise<GetCollectionDataResponse>;
declare function getCollectionDataByCollectionId(args: {
    endlessConfig: EndlessConfig;
    collectionId: AccountAddressInput;
}): Promise<GetCollectionDataResponse>;
declare function getCollectionId(args: {
    endlessConfig: EndlessConfig;
    creatorAddress: AccountAddressInput;
    collectionName: string;
    options?: TokenStandardArg;
}): Promise<string>;
declare function mintDigitalAssetTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    collection: string;
    description: string;
    name: string;
    uri: string;
    propertyKeys?: Array<string>;
    propertyTypes?: Array<PropertyType>;
    propertyValues?: Array<PropertyValue>;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function transferDigitalAssetTransaction(args: {
    endlessConfig: EndlessConfig;
    sender: Account;
    digitalAssetAddress: AccountAddressInput;
    recipient: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function mintSoulBoundTransaction(args: {
    endlessConfig: EndlessConfig;
    account: Account;
    collection: string;
    description: string;
    name: string;
    uri: string;
    recipient: AccountAddressInput;
    propertyKeys?: Array<string>;
    propertyTypes?: Array<PropertyType>;
    propertyValues?: Array<PropertyValue>;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function burnDigitalAssetTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function freezeDigitalAssetTransferTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function unfreezeDigitalAssetTransferTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function setDigitalAssetDescriptionTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    description: string;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function setDigitalAssetNameTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    name: string;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function setDigitalAssetURITransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    uri: string;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function addDigitalAssetPropertyTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    propertyKey: string;
    propertyType: PropertyType;
    propertyValue: PropertyValue;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function removeDigitalAssetPropertyTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    propertyKey: string;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function updateDigitalAssetPropertyTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    propertyKey: string;
    propertyType: PropertyType;
    propertyValue: PropertyValue;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function addDigitalAssetTypedPropertyTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    propertyKey: string;
    propertyType: PropertyType;
    propertyValue: PropertyValue;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;
declare function updateDigitalAssetTypedPropertyTransaction(args: {
    endlessConfig: EndlessConfig;
    creator: Account;
    propertyKey: string;
    propertyType: PropertyType;
    propertyValue: PropertyValue;
    digitalAssetAddress: AccountAddressInput;
    digitalAssetType?: MoveStructId;
    options?: InputGenerateTransactionOptions;
}): Promise<SimpleTransaction>;

export { type CreateCollectionOptions, type PropertyType, type PropertyValue, addDigitalAssetPropertyTransaction, addDigitalAssetTypedPropertyTransaction, burnDigitalAssetTransaction, createCollectionTransaction, freezeDigitalAssetTransferTransaction, getCollectionData, getCollectionDataByCollectionId, getCollectionId, getCurrentDigitalAssetOwnership, getDigitalAssetActivity, getDigitalAssetData, getOwnedDigitalAssets, mintDigitalAssetTransaction, mintSoulBoundTransaction, removeDigitalAssetPropertyTransaction, setDigitalAssetDescriptionTransaction, setDigitalAssetNameTransaction, setDigitalAssetURITransaction, transferDigitalAssetTransaction, unfreezeDigitalAssetTransferTransaction, updateDigitalAssetPropertyTransaction, updateDigitalAssetTypedPropertyTransaction };
