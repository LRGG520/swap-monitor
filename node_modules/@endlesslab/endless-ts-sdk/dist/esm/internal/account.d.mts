import { EndlessConfig } from '../api/endlessConfig.mjs';
import { AccountAddressInput, AccountAddress } from '../core/accountAddress.mjs';
import { AccountData, PaginationArgs, LedgerVersionArg, MoveModuleBytecode, TransactionResponse, MoveResource, MoveStructId, TokenStandardArg, OrderByArg, PaginationArgsOfIndexer, WhereArg } from '../types/index.mjs';
import { A as AuthenticationKey } from '../authenticationKey-D6R4BM6s.mjs';
import { PrivateKey } from '../core/crypto/privateKey.mjs';
import { A as Account } from '../Ed25519Account-3zbpSq0y.mjs';
import { CurrentFungibleAssetBalancesBoolExp } from '../types/generated/types.mjs';
import { GetAccountOwnedTokensQueryResponse, GetAccountOwnedTokensFromCollectionResponse, GetAccountCollectionsWithOwnedTokenResponse, GetAccountCoinsDataResponse, GetCreatedCoinDataResponse, GetAccountOwnedObjectsResponse, GetAccountsCoinBalanceResponse } from '../types/indexer.mjs';
import '../utils/apiEndpoints.mjs';
import '../utils/const.mjs';
import '../types/generated/operations.mjs';
import '../bcs/serializer.mjs';
import '../core/hex.mjs';
import '../core/common.mjs';
import '../bcs/deserializer.mjs';
import '../transactions/instances/transactionArgument.mjs';
import '../core/crypto/signature.mjs';
import '../transactions/authenticator/account.mjs';
import '../core/crypto/ed25519.mjs';
import '../core/crypto/multiEd25519.mjs';
import '../core/crypto/multiKey.mjs';
import '../core/crypto/singleKey.mjs';
import '../core/crypto/bls12381.mjs';
import '../core/crypto/multiAuthKey.mjs';
import '../transactions/types.mjs';
import '../bcs/serializable/moveStructs.mjs';
import '../bcs/serializable/movePrimitives.mjs';
import '../bcs/serializable/fixedBytes.mjs';
import '../transactions/instances/rawTransaction.mjs';
import '../transactions/instances/chainId.mjs';
import '../transactions/instances/transactionPayload.mjs';
import '../transactions/instances/identifier.mjs';
import '../transactions/instances/moduleId.mjs';
import '../transactions/typeTag/index.mjs';
import '../transactions/instances/simpleTransaction.mjs';
import '../transactions/instances/multiAgentTransaction.mjs';

/**
 * This file contains the underlying implementations for exposed API surface in
 * the {@link api/account}. By moving the methods out into a separate file,
 * other namespaces and processes can access these methods without depending on the entire
 * account namespace and without having a dependency cycle error.
 */

declare function getInfo(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
}): Promise<AccountData>;
declare function getModules(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    options?: PaginationArgs & LedgerVersionArg;
}): Promise<MoveModuleBytecode[]>;
/**
 * Queries for a move module given account address and module name
 *
 * @param args.accountAddress Hex-encoded 32 byte Endless account address
 * @param args.moduleName The name of the module
 * @param args.query.ledgerVersion Specifies ledger version of transactions. By default, latest version will be used
 * @returns The move module.
 */
declare function getModule(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    moduleName: string;
    options?: LedgerVersionArg;
}): Promise<MoveModuleBytecode>;
declare function getTransactions(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    options?: PaginationArgs;
}): Promise<TransactionResponse[]>;
declare function getResources(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    options?: PaginationArgs & LedgerVersionArg;
}): Promise<MoveResource[]>;
declare function getResource<T extends {}>(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    resourceType: MoveStructId;
    options?: LedgerVersionArg;
}): Promise<T>;
declare function lookupOriginalAccountAddress(args: {
    endlessConfig: EndlessConfig;
    authenticationKey: AccountAddressInput;
    options?: LedgerVersionArg;
}): Promise<AccountAddress>;
declare function getAccountTokensCount(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
}): Promise<number>;
declare function getAccountOwnedTokens(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;
}): Promise<GetAccountOwnedTokensQueryResponse>;
declare function getAccountOwnedTokensFromCollectionAddress(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    collectionAddress: AccountAddressInput;
    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;
}): Promise<GetAccountOwnedTokensFromCollectionResponse>;
declare function getAccountCollectionsWithOwnedTokens(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;
}): Promise<GetAccountCollectionsWithOwnedTokenResponse>;
declare function getAccountTransactionsCount(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
}): Promise<number>;
declare function getAccountCoinAmount(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    coinId: string;
}): Promise<number>;
declare function getCoinsDataCreatedBy(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    options?: PaginationArgsOfIndexer & OrderByArg<GetAccountCoinsDataResponse> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;
}): Promise<GetCreatedCoinDataResponse>;
declare function getAccountCoinsData(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    options?: PaginationArgsOfIndexer & OrderByArg<GetAccountCoinsDataResponse> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;
}): Promise<GetAccountCoinsDataResponse>;
declare function getAccountCoinsCount(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
}): Promise<number>;
declare function getAccountOwnedObjects(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput;
    options?: PaginationArgs & OrderByArg<GetAccountOwnedObjectsResponse[0]>;
}): Promise<GetAccountOwnedObjectsResponse>;
/**
 * NOTE: There is a potential issue once unified single signer scheme will be adopted
 * by the community.
 *
 * Becuase on could create 2 accounts with the same private key with this new authenticator type,
 * weâ€™ll need to determine the order in which we lookup the accounts. First unified
 * scheme and then legacy scheme vs first legacy scheme and then unified scheme.
 *
 */
declare function deriveAccountFromPrivateKey(args: {
    endlessConfig: EndlessConfig;
    privateKey: PrivateKey;
}): Promise<Account>;
declare function isAccountExist(args: {
    endlessConfig: EndlessConfig;
    authKey: AuthenticationKey;
}): Promise<boolean>;
declare function getAccountsCoinBalance(args: {
    endlessConfig: EndlessConfig;
    accountAddress: AccountAddressInput[];
    coinAddress: AccountAddressInput;
}): Promise<GetAccountsCoinBalanceResponse>;

export { deriveAccountFromPrivateKey, getAccountCoinAmount, getAccountCoinsCount, getAccountCoinsData, getAccountCollectionsWithOwnedTokens, getAccountOwnedObjects, getAccountOwnedTokens, getAccountOwnedTokensFromCollectionAddress, getAccountTokensCount, getAccountTransactionsCount, getAccountsCoinBalance, getCoinsDataCreatedBy, getInfo, getModule, getModules, getResource, getResources, getTransactions, isAccountExist, lookupOriginalAccountAddress };
