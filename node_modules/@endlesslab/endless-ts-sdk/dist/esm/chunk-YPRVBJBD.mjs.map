{"version":3,"sources":["../../src/internal/general.ts"],"sourcesContent":["// Copyright © Endless\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/general}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * general namespace and without having a dependency cycle error.\n */\n\nimport { EndlessConfig } from \"../api/endlessConfig\";\nimport { getEndlessFullNode, postEndlessIndexer } from \"../client\";\nimport { GetChainTopUserTransactionsResponse, GetProcessorStatusResponse, GraphqlQuery, LedgerInfo } from \"../types\";\nimport { GetChainTopUserTransactionsQuery, GetProcessorStatusQuery } from \"../types/generated/operations\";\nimport { GetChainTopUserTransactions, GetProcessorStatus } from \"../types/generated/queries\";\nimport { ProcessorType } from \"../utils/const\";\n\nexport async function getLedgerInfo(args: { endlessConfig: EndlessConfig }): Promise<LedgerInfo> {\n  const { endlessConfig } = args;\n  const { data } = await getEndlessFullNode<{}, LedgerInfo>({\n    endlessConfig,\n    originMethod: \"getLedgerInfo\",\n    path: \"\",\n  });\n  return data;\n}\n\nexport async function getChainTopUserTransactions(args: {\n  endlessConfig: EndlessConfig;\n  limit: number;\n}): Promise<GetChainTopUserTransactionsResponse> {\n  const { endlessConfig, limit } = args;\n  const graphqlQuery = {\n    query: GetChainTopUserTransactions,\n    variables: { limit },\n  };\n\n  const data = await queryIndexer<GetChainTopUserTransactionsQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getChainTopUserTransactions\",\n  });\n\n  return data.user_transactions;\n}\n\nexport async function queryIndexer<T extends {}>(args: {\n  endlessConfig: EndlessConfig;\n  query: GraphqlQuery;\n  originMethod?: string;\n}): Promise<T> {\n  const { endlessConfig, query, originMethod } = args;\n  const { data } = await postEndlessIndexer<GraphqlQuery, T>({\n    endlessConfig,\n    originMethod: originMethod ?? \"queryIndexer\",\n    path: \"\",\n    body: query,\n    overrides: { WITH_CREDENTIALS: false },\n  });\n  return data;\n}\n\nexport async function getProcessorStatuses(args: { endlessConfig: EndlessConfig }): Promise<GetProcessorStatusResponse> {\n  const { endlessConfig } = args;\n\n  const graphqlQuery = {\n    query: GetProcessorStatus,\n  };\n\n  const data = await queryIndexer<GetProcessorStatusQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatuses\",\n  });\n\n  return data.processor_status;\n}\n\nexport async function getIndexerLastSuccessVersion(args: { endlessConfig: EndlessConfig }): Promise<bigint> {\n  const response = await getProcessorStatuses({ endlessConfig: args.endlessConfig });\n  return BigInt(response[0].last_success_version);\n}\n\nexport async function getProcessorStatus(args: {\n  endlessConfig: EndlessConfig;\n  processorType: ProcessorType;\n}): Promise<GetProcessorStatusResponse[0]> {\n  const { endlessConfig, processorType } = args;\n\n  const whereCondition: { processor: { _eq: string } } = {\n    processor: { _eq: processorType },\n  };\n\n  const graphqlQuery = {\n    query: GetProcessorStatus,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetProcessorStatusQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatus\",\n  });\n\n  return data.processor_status[0];\n}\n"],"mappings":"6HAkBA,eAAsBA,EAAcC,EAA6D,CAC/F,GAAM,CAAE,cAAAC,CAAc,EAAID,EACpB,CAAE,KAAAE,CAAK,EAAI,MAAMC,EAAmC,CACxD,cAAAF,EACA,aAAc,gBACd,KAAM,EACR,CAAC,EACD,OAAOC,CACT,CAEA,eAAsBE,EAA4BJ,EAGD,CAC/C,GAAM,CAAE,cAAAC,EAAe,MAAAI,CAAM,EAAIL,EAYjC,OANa,MAAMM,EAA+C,CAChE,cAAAL,EACA,MAPmB,CACnB,MAAOM,EACP,UAAW,CAAE,MAAAF,CAAM,CACrB,EAKE,aAAc,6BAChB,CAAC,GAEW,iBACd,CAEA,eAAsBC,EAA2BN,EAIlC,CACb,GAAM,CAAE,cAAAC,EAAe,MAAAO,EAAO,aAAAC,CAAa,EAAIT,EACzC,CAAE,KAAAE,CAAK,EAAI,MAAMQ,EAAoC,CACzD,cAAAT,EACA,aAAcQ,GAAgB,eAC9B,KAAM,GACN,KAAMD,EACN,UAAW,CAAE,iBAAkB,EAAM,CACvC,CAAC,EACD,OAAON,CACT,CAEA,eAAsBS,EAAqBX,EAA6E,CACtH,GAAM,CAAE,cAAAC,CAAc,EAAID,EAY1B,OANa,MAAMM,EAAsC,CACvD,cAAAL,EACA,MANmB,CACnB,MAAOW,CACT,EAKE,aAAc,sBAChB,CAAC,GAEW,gBACd,CAEA,eAAsBC,EAA6Bb,EAAyD,CAC1G,IAAMc,EAAW,MAAMH,EAAqB,CAAE,cAAeX,EAAK,aAAc,CAAC,EACjF,OAAO,OAAOc,EAAS,CAAC,EAAE,oBAAoB,CAChD,CAEA,eAAsBC,EAAmBf,EAGE,CACzC,GAAM,CAAE,cAAAC,EAAe,cAAAe,CAAc,EAAIhB,EAmBzC,OANa,MAAMM,EAAsC,CACvD,cAAAL,EACA,MATmB,CACnB,MAAOW,EACP,UAAW,CACT,gBAPmD,CACrD,UAAW,CAAE,IAAKI,CAAc,CAClC,CAME,CACF,EAKE,aAAc,oBAChB,CAAC,GAEW,iBAAiB,CAAC,CAChC","names":["getLedgerInfo","args","endlessConfig","data","getEndlessFullNode","getChainTopUserTransactions","limit","queryIndexer","GetChainTopUserTransactions","query","originMethod","postEndlessIndexer","getProcessorStatuses","GetProcessorStatus","getIndexerLastSuccessVersion","response","getProcessorStatus","processorType"]}