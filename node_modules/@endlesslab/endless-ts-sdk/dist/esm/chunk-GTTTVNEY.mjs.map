{"version":3,"sources":["../../src/core/crypto/bls12381.ts"],"sourcesContent":["// Copyright © Endless\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bls12_381 as bls } from \"@noble/curves/bls12-381\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Hex } from \"../hex\";\nimport { HexInput, SigningScheme as AuthenticationKeyScheme } from \"../../types\";\nimport { PrivateKey } from \"./privateKey\";\nimport { AccountPublicKey, VerifySignatureArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { convertSigningMessage } from \"./utils\";\n\nexport class Bls12381PublicKey extends AccountPublicKey {\n  /**\n   * Length of an Bls12381 public key\n   */\n  static readonly LENGTH: number = 48;\n\n  /**\n   * Bytes of the public key\n   * @private\n   */\n  private readonly key: Hex;\n\n  /**\n   * Create a new PublicKey instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Bls12381PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${Bls12381PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies a signed data with a public key\n   * @param args.message a signed message as a Hex string or Uint8Array\n   * @param args.signature the signature of the message\n   */\n  verifySignature(args: VerifySignatureArgs): boolean {\n    const { message, signature } = args;\n    if (!(signature instanceof Bls12381Signature)) {\n      return false;\n    }\n    const messageToVerify = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToVerify).toUint8Array();\n    const signatureBytes = signature.toUint8Array();\n    const publicKeyBytes = this.key.toUint8Array();\n\n    return bls.verify(signatureBytes, messageBytes, publicKeyBytes);\n  }\n\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.Bls12381,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Bls12381PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Bls12381PublicKey(bytes);\n  }\n\n  // endregion\n\n  /**\n   * @deprecated use `instanceof Ed25519PublicKey` instead.\n   */\n  static isPublicKey(publicKey: AccountPublicKey): publicKey is Bls12381PublicKey {\n    return publicKey instanceof Bls12381PublicKey;\n  }\n}\n\n/**\n * Represents the private key of an Ed25519 key pair.\n */\nexport class Bls12381PrivateKey extends Serializable implements PrivateKey {\n  /**\n   * Length of an Ed25519 private key\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The Ed25519 signing key\n   * @private\n   */\n  private readonly signingKey: Hex;\n\n  // region Constructors\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * @param hexInput HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== Bls12381PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Bls12381PrivateKey.LENGTH}`);\n    }\n\n    // Create keyPair from Private key in Uint8Array format\n    this.signingKey = privateKeyHex;\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Ed25519PrivateKey\n   */\n  static generate(): Bls12381PrivateKey {\n    const keyPair = bls.utils.randomPrivateKey();\n    return new Bls12381PrivateKey(keyPair);\n  }\n\n  // endregion\n\n  // region PrivateKey\n\n  /**\n   * Derive the Ed25519PublicKey for this private key.\n   *\n   * @returns Ed25519PublicKey\n   */\n  publicKey(): Bls12381PublicKey {\n    const bytes = bls.getPublicKey(this.signingKey.toUint8Array());\n    return new Bls12381PublicKey(bytes);\n  }\n\n  /**\n   * Sign the given message with the private key.\n   *\n   * @param message a message as a string or Uint8Array\n   * @returns Signature\n   */\n  sign(message: HexInput): Bls12381Signature {\n    const messageToSign = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToSign).toUint8Array();\n    const signatureBytes = bls.sign(messageBytes, this.signingKey.toUint8Array());\n    return new Bls12381Signature(signatureBytes);\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the private key\n   */\n  toUint8Array(): Uint8Array {\n    return this.signingKey.toUint8Array();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key\n   */\n  toString(): string {\n    return this.signingKey.toString();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Bls12381PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Bls12381PrivateKey(bytes);\n  }\n\n  // endregion\n\n  /**\n   * @deprecated use `instanceof Ed25519PrivateKey` instead.\n   */\n  static isPrivateKey(privateKey: PrivateKey): privateKey is Bls12381PrivateKey {\n    return privateKey instanceof Bls12381PrivateKey;\n  }\n}\n\n/**\n * A signature of a message signed using an Ed25519 private key\n */\nexport class Bls12381Signature extends Signature {\n  /**\n   * Length of an Ed25519 signature\n   */\n  static readonly LENGTH = 96;\n\n  /**\n   * The signature bytes\n   * @private\n   */\n  private readonly data: Hex;\n\n  // region Constructors\n\n  constructor(hexInput: HexInput) {\n    super();\n    const data = Hex.fromHexInput(hexInput);\n    if (data.toUint8Array().length !== Bls12381Signature.LENGTH) {\n      throw new Error(`Signature length should be ${Bls12381Signature.LENGTH}`);\n    }\n    this.data = data;\n  }\n\n  // endregion\n\n  // region Signature\n\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Bls12381Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Bls12381Signature(bytes);\n  }\n  // endregion\n}\n"],"mappings":"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","names":["bls","_Bls12381PublicKey","AccountPublicKey","hexInput","hex","Hex","args","message","signature","Bls12381Signature","messageToVerify","convertSigningMessage","messageBytes","signatureBytes","publicKeyBytes","bls","AuthenticationKey","serializer","deserializer","bytes","publicKey","Bls12381PublicKey","_Bls12381PrivateKey","Serializable","privateKeyHex","keyPair","messageToSign","privateKey","Bls12381PrivateKey","_Bls12381Signature","Signature","data"]}