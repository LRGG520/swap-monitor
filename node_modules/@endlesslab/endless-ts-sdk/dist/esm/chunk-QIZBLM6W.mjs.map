{"version":3,"sources":["../../src/client/get.ts"],"sourcesContent":["import { EndlessConfig } from \"../api/endlessConfig\";\nimport { endlessRequest } from \"./core\";\nimport { EndlessResponse } from \"./types\";\nimport { AnyNumber, ClientConfig, MimeType } from \"../types\";\nimport { EndlessApiType } from \"../utils/const\";\n\nexport type GetRequestOptions = {\n  /**\n   * The config for the API client\n   */\n  endlessConfig: EndlessConfig;\n  /**\n   * The type of API endpoint to call e.g. fullnode, indexer, etc\n   */\n  type: EndlessApiType;\n  /**\n   * The name of the API method\n   */\n  originMethod: string;\n  /**\n   * The URL path to the API method\n   */\n  path: string;\n  /**\n   * The content type of the request body\n   */\n  contentType?: MimeType;\n  /**\n   * The accepted content type of the response of the API\n   */\n  acceptType?: MimeType;\n  /**\n   * The query parameters for the request\n   */\n  params?: Record<string, string | AnyNumber | boolean | undefined>;\n  /**\n   * Specific client overrides for this request to override endlessConfig\n   */\n  overrides?: ClientConfig;\n};\n\nexport type GetEndlessRequestOptions = Omit<GetRequestOptions, \"type\">;\n\n/**\n * Main function to do a Get request\n *\n * @param options GetRequestOptions\n * @returns\n */\nexport async function get<Req extends {}, Res extends {}>(\n  options: GetRequestOptions,\n): Promise<EndlessResponse<Req, Res>> {\n  const { endlessConfig, overrides, params, contentType, acceptType, path, originMethod, type } = options;\n  const url = endlessConfig.getRequestUrl(type);\n\n  return endlessRequest<Req, Res>(\n    {\n      url,\n      method: \"GET\",\n      originMethod,\n      path,\n      contentType,\n      acceptType,\n      params,\n      overrides: {\n        ...endlessConfig.clientConfig,\n        ...overrides,\n      },\n    },\n    endlessConfig,\n    options.type,\n  );\n}\n\nexport async function getEndlessFullNode<Req extends {}, Res extends {}>(\n  options: GetEndlessRequestOptions,\n): Promise<EndlessResponse<Req, Res>> {\n  const { endlessConfig } = options;\n\n  return get<Req, Res>({\n    ...options,\n    type: EndlessApiType.FULLNODE,\n    overrides: {\n      ...endlessConfig.clientConfig,\n      ...endlessConfig.fullnodeConfig,\n      ...options.overrides,\n      HEADERS: { ...endlessConfig.clientConfig?.HEADERS, ...endlessConfig.fullnodeConfig?.HEADERS },\n    },\n  });\n}\n\nexport async function getEndlessIndexer<Req extends {}, Res extends {}>(\n  options: GetEndlessRequestOptions,\n): Promise<EndlessResponse<Req, Res>> {\n  const { endlessConfig } = options;\n\n  return get<Req, Res>({\n    ...options,\n    type: EndlessApiType.INDEXER,\n    overrides: {\n      ...endlessConfig.clientConfig,\n      ...endlessConfig.indexerConfig,\n      HEADERS: { ...endlessConfig.clientConfig?.HEADERS, ...endlessConfig.indexerConfig?.HEADERS },\n    },\n  });\n}\n\n/// This function is a helper for paginating using a function wrapping an API\nexport async function paginateWithCursor<Req extends Record<string, any>, Res extends Array<{}>>(\n  options: GetEndlessRequestOptions,\n): Promise<Res> {\n  const out: any[] = [];\n  let cursor: string | undefined;\n  const requestParams = options.params as { start?: string; limit?: number };\n  do {\n    // eslint-disable-next-line no-await-in-loop\n    const response = await get<Req, Res>({\n      type: EndlessApiType.FULLNODE,\n      endlessConfig: options.endlessConfig,\n      originMethod: options.originMethod,\n      path: options.path,\n      params: requestParams,\n      overrides: options.overrides,\n    });\n    /**\n     * the cursor is a \"state key\" from the API perspective. Client\n     * should not need to \"care\" what it represents but just use it\n     * to query the next chunk of data.\n     */\n    cursor = response.headers[\"x-endless-cursor\"];\n    // Now that we have the cursor (if any), we remove the headers before\n    // adding these to the output of this function.\n    delete response.headers;\n    out.push(...response.data);\n    requestParams.start = cursor;\n  } while (cursor !== null && cursor !== undefined);\n  return out as Res;\n}\n"],"mappings":"yCAiDA,eAAsBA,EACpBC,EACoC,CACpC,GAAM,CAAE,cAAAC,EAAe,UAAAC,EAAW,OAAAC,EAAQ,YAAAC,EAAa,WAAAC,EAAY,KAAAC,EAAM,aAAAC,EAAc,KAAAC,CAAK,EAAIR,EAC1FS,EAAMR,EAAc,cAAcO,CAAI,EAE5C,OAAOE,EACL,CACE,IAAAD,EACA,OAAQ,MACR,aAAAF,EACA,KAAAD,EACA,YAAAF,EACA,WAAAC,EACA,OAAAF,EACA,UAAW,CACT,GAAGF,EAAc,aACjB,GAAGC,CACL,CACF,EACAD,EACAD,EAAQ,IACV,CACF,CAEA,eAAsBW,EACpBX,EACoC,CACpC,GAAM,CAAE,cAAAC,CAAc,EAAID,EAE1B,OAAOD,EAAc,CACnB,GAAGC,EACH,gBACA,UAAW,CACT,GAAGC,EAAc,aACjB,GAAGA,EAAc,eACjB,GAAGD,EAAQ,UACX,QAAS,CAAE,GAAGC,EAAc,cAAc,QAAS,GAAGA,EAAc,gBAAgB,OAAQ,CAC9F,CACF,CAAC,CACH,CAEA,eAAsBW,EACpBZ,EACoC,CACpC,GAAM,CAAE,cAAAC,CAAc,EAAID,EAE1B,OAAOD,EAAc,CACnB,GAAGC,EACH,eACA,UAAW,CACT,GAAGC,EAAc,aACjB,GAAGA,EAAc,cACjB,QAAS,CAAE,GAAGA,EAAc,cAAc,QAAS,GAAGA,EAAc,eAAe,OAAQ,CAC7F,CACF,CAAC,CACH,CAGA,eAAsBY,EACpBb,EACc,CACd,IAAMc,EAAa,CAAC,EAChBC,EACEC,EAAgBhB,EAAQ,OAC9B,EAAG,CAED,IAAMiB,EAAW,MAAMlB,EAAc,CACnC,gBACA,cAAeC,EAAQ,cACvB,aAAcA,EAAQ,aACtB,KAAMA,EAAQ,KACd,OAAQgB,EACR,UAAWhB,EAAQ,SACrB,CAAC,EAMDe,EAASE,EAAS,QAAQ,kBAAkB,EAG5C,OAAOA,EAAS,QAChBH,EAAI,KAAK,GAAGG,EAAS,IAAI,EACzBD,EAAc,MAAQD,CACxB,OAASA,GAAW,MACpB,OAAOD,CACT","names":["get","options","endlessConfig","overrides","params","contentType","acceptType","path","originMethod","type","url","endlessRequest","getEndlessFullNode","getEndlessIndexer","paginateWithCursor","out","cursor","requestParams","response"]}