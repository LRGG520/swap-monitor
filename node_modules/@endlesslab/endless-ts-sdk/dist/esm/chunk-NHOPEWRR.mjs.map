{"version":3,"sources":["../../src/api/transaction.ts"],"sourcesContent":["// Copyright © Endless\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { EndlessConfig } from \"./endlessConfig\";\nimport {\n  getGasPriceEstimation,\n  getTransactionByHash,\n  getTransactionByVersion,\n  getTransactions,\n  isTransactionPending,\n  waitForTransaction,\n} from \"../internal/transaction\";\nimport {\n  AnyNumber,\n  CommittedTransactionResponse,\n  GasEstimation,\n  HexInput,\n  PaginationArgs,\n  PendingTransactionResponse,\n  TransactionResponse,\n  WaitForTransactionOptions,\n} from \"../types\";\nimport {\n  getSigningMessage,\n  publicPackageTransaction,\n  rotateAuthKey,\n  signAndSubmitTransaction,\n  signTransaction,\n} from \"../internal/transactionSubmission\";\nimport {\n  AccountAuthenticator,\n  AnyRawTransaction,\n  EntryFunctionABI,\n  InputGenerateTransactionOptions,\n  InputGenerateTransactionPayloadData,\n  TypeTagAddress,\n} from \"../transactions\";\nimport { AccountAddressInput, PrivateKey } from \"../core\";\nimport { Account } from \"../account\";\nimport { Build } from \"./transactionSubmission/build\";\nimport { Simulate } from \"./transactionSubmission/simulate\";\nimport { Submit } from \"./transactionSubmission/submit\";\nimport { TransactionManagement } from \"./transactionSubmission/management\";\nimport { SimpleTransaction } from \"../transactions/instances/simpleTransaction\";\n\nexport class Transaction {\n  readonly config: EndlessConfig;\n\n  readonly build: Build;\n\n  readonly simulate: Simulate;\n\n  readonly submit: Submit;\n\n  readonly batch: TransactionManagement;\n\n  constructor(config: EndlessConfig) {\n    this.config = config;\n    this.build = new Build(this.config);\n    this.simulate = new Simulate(this.config);\n    this.submit = new Submit(this.config);\n    this.batch = new TransactionManagement(this.config);\n  }\n\n  /**\n   * Queries on-chain transactions. This function will not return pending\n   * transactions. For that, use `getTransactionsByHash`.\n   *\n   * @example\n   * const transactions = await endless.getTransactions()\n   *\n   * @param args.options.offset The number transaction to start with\n   * @param args.options.limit Number of results to return\n   *\n   * @returns Array of on-chain transactions\n   */\n  async getTransactions(args?: { options?: PaginationArgs }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transaction by version. This function will not return pending transactions.\n   *\n   * @example\n   * const transaction = await endless.getTransactions({ledgerVersion:1})\n   *\n   * @param args.ledgerVersion - Transaction version is an unsigned 64-bit number.\n   * @returns On-chain transaction. Only on-chain transactions have versions, so this\n   * function cannot be used to query pending transactions.\n   */\n  async getTransactionByVersion(args: { ledgerVersion: AnyNumber }): Promise<TransactionResponse> {\n    return getTransactionByVersion({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transaction by transaction hash. This function will return pending transactions.\n   *\n   * @example\n   * const transaction = await endless.getTransactionByHash({transactionHash:\"0x123\"})\n   *\n   * @param args.transactionHash - Transaction hash should be hex-encoded bytes string with 0x prefix.\n   * @returns Transaction from mempool (pending) or on-chain (committed) transaction\n   */\n  async getTransactionByHash(args: { transactionHash: HexInput }): Promise<TransactionResponse> {\n    return getTransactionByHash({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Defines if specified transaction is currently in pending state\n   *\n   * To create a transaction hash:\n   *\n   * 1. Create a hash message from the bytes: \"Endless::Transaction\" bytes + the BCS-serialized Transaction bytes.\n   * 2. Apply hash algorithm SHA3-256 to the hash message bytes.\n   * 3. Hex-encode the hash bytes with 0x prefix.\n   *\n   * @example\n   * const isPendingTransaction = await endless.isPendingTransaction({transactionHash:\"0x123\"})\n   *\n   * @param args.transactionHash A hash of transaction\n   * @returns `true` if transaction is in pending state and `false` otherwise\n   */\n  async isPendingTransaction(args: { transactionHash: HexInput }): Promise<boolean> {\n    return isTransactionPending({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Waits for a transaction to move past the pending state.\n   *\n   * There are 4 cases.\n   * 1. Transaction is successfully processed and committed to the chain.\n   *    - The function will resolve with the transaction response from the API.\n   * 2. Transaction is rejected for some reason, and is therefore not committed to the blockchain.\n   *    - The function will throw an EndlessApiError with an HTTP status code indicating some problem with the request.\n   * 3. Transaction is committed but execution failed, meaning no changes were\n   *    written to the blockchain state.\n   *    - If `checkSuccess` is true, the function will throw a FailedTransactionError\n   *      If `checkSuccess` is false, the function will resolve with the transaction response where the `success` field is false.\n   * 4. Transaction does not move past the pending state within `args.options.timeoutSecs` seconds.\n   *    - The function will throw a WaitForTransactionError\n   *\n   * @example\n   * const transaction = await endless.waitForTransaction({transactionHash:\"0x123\"})\n   *\n   * @param args.transactionHash The hash of a transaction previously submitted to the blockchain.\n   * @param args.options.timeoutSecs Timeout in seconds. Defaults to 20 seconds.\n   * @param args.options.checkSuccess A boolean which controls whether the function will error if the transaction failed.\n   *   Defaults to true.  See case 3 above.\n   * @returns The transaction on-chain.  See above for more details.\n   */\n  async waitForTransaction(args: {\n    transactionHash: HexInput;\n    options?: WaitForTransactionOptions;\n  }): Promise<CommittedTransactionResponse> {\n    return waitForTransaction({\n      endlessConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Gives an estimate of the gas unit price required to get a\n   * transaction on chain in a reasonable amount of time.\n   * For more information {@link https://api.mainnet.endlesslabs.com/v1/spec#/operations/estimate_gas_price}\n   *\n   * @returns Object holding the outputs of the estimate gas API\n   *\n   * @example\n   * const gasPrice = await endless.waitForTransaction()\n   */\n  async getGasPriceEstimation(): Promise<GasEstimation> {\n    return getGasPriceEstimation({\n      endlessConfig: this.config,\n    });\n  }\n\n  /**\n   * Returns a signing message for a transaction.\n   *\n   * This allows a user to sign a transaction using their own preferred signing method, and\n   * then submit it to the network.\n   *\n   * @example\n   * const transaction = await endless.transaction.build.simple({...})\n   * const message = await endless.getSigningMessage({transaction})\n   *\n   * @param args.transaction A raw transaction for signing elsewhere\n   */\n  // eslint-disable-next-line class-methods-use-this\n  getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n    return getSigningMessage(args);\n  }\n\n  /**\n   * Generates a transaction to publish a move package to chain.\n   *\n   * To get the `metadataBytes` and `byteCode`, can compile using Endless CLI with command\n   * `endless move compile --save-metadata ...`,\n   * For more info {@link https://endless.dev/tutorials/your-first-dapp/#step-4-publish-a-move-module}\n   *\n   * @example\n   * const transaction = await endless.publishPackageTransaction({\n   *  account: alice,\n   *  metadataBytes,\n   *  moduleBytecode: [byteCode],\n   * })\n   *\n   * @param args.account The publisher account\n   * @param args.metadataBytes The package metadata bytes\n   * @param args.moduleBytecode An array of the bytecode of each module in the package in compiler output order\n   *\n   * @returns A SimpleTransaction that can be simulated or submitted to chain\n   */\n  async publishPackageTransaction(args: {\n    account: AccountAddressInput;\n    metadataBytes: HexInput;\n    moduleBytecode: Array<HexInput>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<SimpleTransaction> {\n    return publicPackageTransaction({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Rotate an account's auth key. After rotation, only the new private key can be used to sign txns for\n   * the account.\n   * Note: Only legacy Ed25519 scheme is supported for now.\n   * More info: {@link https://endless.dev/guides/account-management/key-rotation/}\n   *\n   * @example\n   * const response = await endless.rotateAuthKey({\n   *  fromAccount: alice,\n   *  toNewPrivateKey: new ED25519PublicKey(\"0x123\"),\n   * })\n   *\n   * @param args.fromAccount The account to rotate the auth key for\n   * @param args.toNewPrivateKey The new private key to rotate to\n   *\n   * @returns PendingTransactionResponse\n   */\n  async rotateAuthKey(args: { fromAccount: Account; toNewPrivateKey: PrivateKey }): Promise<TransactionResponse> {\n    return rotateAuthKey({ endlessConfig: this.config, ...args });\n  }\n\n  /**\n   * Sign a transaction that can later be submitted to chain\n   *\n   * @example\n   * const transaction = await endless.transaction.build.simple({...})\n   * const transaction = await endless.transaction.sign({\n   *  signer: alice,\n   *  transaction\n   * })\n   *\n   * @param args.signer The signer account\n   * @param args.transaction A raw transaction to sign on\n   *\n   * @returns AccountAuthenticator\n   */\n  // eslint-disable-next-line class-methods-use-this\n  sign(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    return signTransaction({\n      ...args,\n    });\n  }\n\n  /**\n   * Sign a transaction as a fee payer that can later be submitted to chain\n   *\n   * @example\n   * const transaction = await endless.transaction.build.simple({...})\n   * const transaction = await endless.transaction.signAsFeePayer({\n   *  signer: alice,\n   *  transaction\n   * })\n   *\n   * @param args.signer The fee payer signer account\n   * @param args.transaction A raw transaction to sign on\n   *\n   * @returns AccountAuthenticator\n   */\n  // eslint-disable-next-line class-methods-use-this\n  signAsFeePayer(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    const { signer, transaction } = args;\n\n    // if transaction doesnt hold a \"feePayerAddress\" prop it means\n    // this is not a fee payer transaction\n    if (!transaction.feePayerAddress) {\n      throw new Error(`Transaction ${transaction} is not a Fee Payer transaction`);\n    }\n\n    // Set the feePayerAddress to the signer account address\n    transaction.feePayerAddress = signer.accountAddress;\n\n    return signTransaction({\n      signer,\n      transaction,\n    });\n  }\n\n  // TRANSACTION SUBMISSION //\n\n  /**\n   * @deprecated Prefer to use `endless.transaction.batch.forSingleAccount()`\n   *\n   * Batch transactions for a single account.\n   *\n   * This function uses a transaction worker that receives payloads to be processed\n   * and submitted to chain.\n   * Note that this process is best for submitting multiple transactions that\n   * dont rely on each other, i.e batch funds, batch token mints, etc.\n   *\n   * If any worker failure, the functions throws an error.\n   *\n   * @param args.sender The sender account to sign and submit the transaction\n   * @param args.data An array of transaction payloads\n   * @param args.options optional. Transaction generation configurations (excluding accountSequenceNumber)\n   *\n   * @return void. Throws if any error\n   */\n  async batchTransactionsForSingleAccount(args: {\n    sender: Account;\n    data: InputGenerateTransactionPayloadData[];\n    options?: Omit<InputGenerateTransactionOptions, \"accountSequenceNumber\">;\n  }): Promise<void> {\n    try {\n      const { sender, data, options } = args;\n      this.batch.forSingleAccount({ sender, data, options });\n    } catch (error: any) {\n      throw new Error(`failed to submit transactions with error: ${error}`);\n    }\n  }\n\n  /**\n   * Sign and submit a single signer transaction to chain\n   *\n   * @param args.signer The signer account to sign the transaction\n   * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses\n   *\n   * @example\n   * const transaction = await endless.transaction.build.simple({...})\n   * const transaction = await endless.signAndSubmitTransaction({\n   *  signer: alice,\n   *  transaction\n   * })\n   *\n   * @return PendingTransactionResponse\n   */\n  async signAndSubmitTransaction(args: {\n    signer: Account;\n    transaction: AnyRawTransaction;\n  }): Promise<PendingTransactionResponse> {\n    const { signer, transaction } = args;\n    return signAndSubmitTransaction({\n      endlessConfig: this.config,\n      signer,\n      transaction,\n    });\n  }\n\n  async fundAccount(args: {\n    signer: Account;\n    address?: string\n  }): Promise<PendingTransactionResponse> {\n    const { signer, address } = args;\n\n    const abi: EntryFunctionABI = {\n      typeParameters: [],\n      parameters: [\n        new TypeTagAddress()\n      ]\n    }\n\n    const transaction = await this.build.simple({\n      sender: signer.accountAddress,\n      data: {\n        function: \"0x1::faucet::fund\",\n        functionArguments: [\n          address || signer.accountAddress\n        ],\n        abi\n      },\n    })\n\n    return signAndSubmitTransaction({\n      endlessConfig: this.config,\n      signer,\n      transaction\n    })\n  }\n}\n"],"mappings":"8VA8CO,IAAMA,EAAN,KAAkB,CAWvB,YAAYC,EAAuB,CACjC,KAAK,OAASA,EACd,KAAK,MAAQ,IAAIC,EAAM,KAAK,MAAM,EAClC,KAAK,SAAW,IAAIC,EAAS,KAAK,MAAM,EACxC,KAAK,OAAS,IAAIC,EAAO,KAAK,MAAM,EACpC,KAAK,MAAQ,IAAIC,EAAsB,KAAK,MAAM,CACpD,CAcA,MAAM,gBAAgBC,EAAqE,CACzF,OAAOC,EAAgB,CACrB,cAAe,KAAK,OACpB,GAAGD,CACL,CAAC,CACH,CAYA,MAAM,wBAAwBA,EAAkE,CAC9F,OAAOE,EAAwB,CAC7B,cAAe,KAAK,OACpB,GAAGF,CACL,CAAC,CACH,CAWA,MAAM,qBAAqBA,EAAmE,CAC5F,OAAOG,EAAqB,CAC1B,cAAe,KAAK,OACpB,GAAGH,CACL,CAAC,CACH,CAiBA,MAAM,qBAAqBA,EAAuD,CAChF,OAAOI,EAAqB,CAC1B,cAAe,KAAK,OACpB,GAAGJ,CACL,CAAC,CACH,CA0BA,MAAM,mBAAmBA,EAGiB,CACxC,OAAOK,EAAmB,CACxB,cAAe,KAAK,OACpB,GAAGL,CACL,CAAC,CACH,CAYA,MAAM,uBAAgD,CACpD,OAAOM,EAAsB,CAC3B,cAAe,KAAK,MACtB,CAAC,CACH,CAeA,kBAAkBN,EAAsD,CACtE,OAAOO,EAAkBP,CAAI,CAC/B,CAsBA,MAAM,0BAA0BA,EAKD,CAC7B,OAAOQ,EAAyB,CAAE,cAAe,KAAK,OAAQ,GAAGR,CAAK,CAAC,CACzE,CAmBA,MAAM,cAAcA,EAA2F,CAC7G,OAAOS,EAAc,CAAE,cAAe,KAAK,OAAQ,GAAGT,CAAK,CAAC,CAC9D,CAkBA,KAAKA,EAAiF,CACpF,OAAOU,EAAgB,CACrB,GAAGV,CACL,CAAC,CACH,CAkBA,eAAeA,EAAiF,CAC9F,GAAM,CAAE,OAAAW,EAAQ,YAAAC,CAAY,EAAIZ,EAIhC,GAAI,CAACY,EAAY,gBACf,MAAM,IAAI,MAAM,eAAeA,CAAW,iCAAiC,EAI7E,OAAAA,EAAY,gBAAkBD,EAAO,eAE9BD,EAAgB,CACrB,OAAAC,EACA,YAAAC,CACF,CAAC,CACH,CAsBA,MAAM,kCAAkCZ,EAItB,CAChB,GAAI,CACF,GAAM,CAAE,OAAAa,EAAQ,KAAAC,EAAM,QAAAC,CAAQ,EAAIf,EAClC,KAAK,MAAM,iBAAiB,CAAE,OAAAa,EAAQ,KAAAC,EAAM,QAAAC,CAAQ,CAAC,CACvD,OAASC,EAAY,CACnB,MAAM,IAAI,MAAM,6CAA6CA,CAAK,EAAE,CACtE,CACF,CAiBA,MAAM,yBAAyBhB,EAGS,CACtC,GAAM,CAAE,OAAAW,EAAQ,YAAAC,CAAY,EAAIZ,EAChC,OAAOiB,EAAyB,CAC9B,cAAe,KAAK,OACpB,OAAAN,EACA,YAAAC,CACF,CAAC,CACH,CAEA,MAAM,YAAYZ,EAGsB,CACtC,GAAM,CAAE,OAAAW,EAAQ,QAAAO,CAAQ,EAAIlB,EAEtBmB,EAAwB,CAC5B,eAAgB,CAAC,EACjB,WAAY,CACV,IAAIC,CACN,CACF,EAEMR,EAAc,MAAM,KAAK,MAAM,OAAO,CAC1C,OAAQD,EAAO,eACf,KAAM,CACJ,SAAU,oBACV,kBAAmB,CACjBO,GAAWP,EAAO,cACpB,EACA,IAAAQ,CACF,CACF,CAAC,EAED,OAAOF,EAAyB,CAC9B,cAAe,KAAK,OACpB,OAAAN,EACA,YAAAC,CACF,CAAC,CACH,CACF","names":["Transaction","config","Build","Simulate","Submit","TransactionManagement","args","getTransactions","getTransactionByVersion","getTransactionByHash","isTransactionPending","waitForTransaction","getGasPriceEstimation","getSigningMessage","publicPackageTransaction","rotateAuthKey","signTransaction","signer","transaction","sender","data","options","error","signAndSubmitTransaction","address","abi","TypeTagAddress"]}