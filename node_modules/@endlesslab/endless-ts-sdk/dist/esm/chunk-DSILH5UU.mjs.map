{"version":3,"sources":["../../src/internal/account.ts"],"sourcesContent":["// Copyright © Endless\n// Copyright © Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/account}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * account namespace and without having a dependency cycle error.\n */\n\nimport { EndlessConfig } from \"../api/endlessConfig\";\nimport { EndlessApiError, getEndlessFullNode, paginateWithCursor, getEndlessIndexer, postEndlessIndexer } from \"../client\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Account } from \"../account\";\nimport { AnyPublicKey, Ed25519PublicKey, PrivateKey } from \"../core/crypto\";\nimport { queryIndexer } from \"./general\";\nimport {\n  AccountData,\n  GetAccountsCoinBalanceResponse,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedObjectsResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  LedgerVersionArg,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructId,\n  OrderByArg,\n  PaginationArgs,\n  PaginationArgsOfIndexer,\n  TokenStandardArg,\n  TransactionResponse,\n  WhereArg,\n  GetCreatedCoinDataResponse,\n} from \"../types\";\nimport {\n  GetAccountCoinsCountQuery,\n  // GetAccountCoinsDataQuery,\n  GetAccountCollectionsWithOwnedTokensQuery,\n  GetAccountOwnedObjectsQuery,\n  GetAccountOwnedTokensFromCollectionQuery,\n  GetAccountOwnedTokensQuery,\n  GetAccountTokensCountQuery,\n  GetAccountTransactionsCountQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetAccountCoinsCount,\n  // GetAccountCoinsData,\n  GetAccountCollectionsWithOwnedTokens,\n  GetAccountOwnedObjects,\n  GetAccountOwnedTokens,\n  GetAccountOwnedTokensFromCollection,\n  GetAccountTokensCount,\n  GetAccountTransactionsCount,\n} from \"../types/generated/queries\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { Secp256k1PrivateKey, AuthenticationKey, Ed25519PrivateKey } from \"../core\";\nimport { CurrentFungibleAssetBalancesBoolExp } from \"../types/generated/types\";\nimport { getTableItem } from \"./table\";\n\nexport async function getInfo(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<AccountData> {\n  const { endlessConfig, accountAddress } = args;\n  const { data } = await getEndlessFullNode<{}, AccountData>({\n    endlessConfig,\n    originMethod: \"getInfo\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}`,\n  });\n  return data;\n}\n\nexport async function getModules(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveModuleBytecode[]> {\n  const { endlessConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, MoveModuleBytecode[]>({\n    endlessConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      start: options?.offset,\n      limit: options?.limit ?? 1000,\n    },\n  });\n}\n\n/**\n * Queries for a move module given account address and module name\n *\n * @param args.accountAddress Hex-encoded 32 byte Endless account address\n * @param args.moduleName The name of the module\n * @param args.query.ledgerVersion Specifies ledger version of transactions. By default, latest version will be used\n * @returns The move module.\n */\nexport async function getModule(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  // We don't memoize the account module by ledger version, as it's not a common use case, this would be handled\n  // by the developer directly\n  if (args.options?.ledgerVersion !== undefined) {\n    return getModuleInner(args);\n  }\n\n  return memoizeAsync(\n    async () => getModuleInner(args),\n    `module-${args.accountAddress}-${args.moduleName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\nasync function getModuleInner(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  moduleName: string;\n  options?: LedgerVersionArg;\n}): Promise<MoveModuleBytecode> {\n  const { endlessConfig, accountAddress, moduleName, options } = args;\n\n  const { data } = await getEndlessFullNode<{}, MoveModuleBytecode>({\n    endlessConfig,\n    originMethod: \"getModule\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/module/${moduleName}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data;\n}\n\nexport async function getTransactions(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { endlessConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    endlessConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/transactions`,\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\nexport async function getResources(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & LedgerVersionArg;\n}): Promise<MoveResource[]> {\n  const { endlessConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, MoveResource[]>({\n    endlessConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      start: options?.offset,\n      limit: options?.limit ?? 999,\n    },\n  });\n}\n\nexport async function getResource<T extends {}>(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  resourceType: MoveStructId;\n  options?: LedgerVersionArg;\n}): Promise<T> {\n  const { endlessConfig, accountAddress, resourceType, options } = args;\n  const { data } = await getEndlessFullNode<{}, MoveResource>({\n    endlessConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.from(accountAddress).toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data.data as T;\n}\n\nexport async function lookupOriginalAccountAddress(args: {\n  endlessConfig: EndlessConfig;\n  authenticationKey: AccountAddressInput;\n  options?: LedgerVersionArg;\n}): Promise<AccountAddress> {\n  const { endlessConfig, authenticationKey, options } = args;\n  type OriginatingAddress = {\n    address_map: { handle: string };\n  };\n  const resource = await getResource<OriginatingAddress>({\n    endlessConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options,\n  });\n\n  const {\n    address_map: { handle },\n  } = resource;\n\n  const authKeyAddress = AccountAddress.from(authenticationKey);\n\n  // If the address is not found in the address map, which means its not rotated\n  // then return the address as is\n  try {\n    const originalAddress = await getTableItem<string>({\n      endlessConfig,\n      handle,\n      data: {\n        key: authKeyAddress.toString(),\n        key_type: \"address\",\n        value_type: \"address\",\n      },\n      options,\n    });\n\n    return AccountAddress.from(originalAddress);\n  } catch (err) {\n    if (err instanceof EndlessApiError && err.data.error_code === \"table_item_not_found\") {\n      return authKeyAddress;\n    }\n\n    throw err;\n  }\n}\n\nexport async function getAccountTokensCount(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { endlessConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number } } = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: { where_condition: whereCondition },\n  };\n\n  const data = await queryIndexer<GetAccountTokensCountQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\",\n  });\n\n  // commonjs (aka cjs) doesnt handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.current_token_ownerships_v2_aggregate.aggregate\n    ? data.current_token_ownerships_v2_aggregate.aggregate.count\n    : 0;\n}\n\nexport async function getAccountOwnedTokens(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensQueryResponse[0]>;\n}): Promise<GetAccountOwnedTokensQueryResponse> {\n  const { endlessConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string }; amount: { _gt: number }; token_standard?: { _eq: string } } =\n  {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\nexport async function getAccountOwnedTokensFromCollectionAddress(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  collectionAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountOwnedTokensFromCollectionResponse[0]>;\n}): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n  const { endlessConfig, accountAddress, collectionAddress, options } = args;\n  const ownerAddress = AccountAddress.from(accountAddress).toStringLong();\n  const collAddress = AccountAddress.from(collectionAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    current_token_data: { collection_id: { _eq: string } };\n    amount: { _gt: number };\n    token_standard?: { _eq: string };\n  } = {\n    owner_address: { _eq: ownerAddress },\n    current_token_data: { collection_id: { _eq: collAddress } },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensFromCollectionQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\nexport async function getAccountCollectionsWithOwnedTokens(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  options?: TokenStandardArg & PaginationArgs & OrderByArg<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n}): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n  const { endlessConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: {\n    owner_address: { _eq: string };\n    amount: { _gt: number };\n    current_collection?: { token_standard: { _eq: string } };\n  } = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: { _eq: options?.tokenStandard },\n    };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCollectionsWithOwnedTokensQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\",\n  });\n\n  return data.current_collection_ownership_v2_view;\n}\n\nexport async function getAccountTransactionsCount(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { endlessConfig, accountAddress } = args;\n\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountTransactionsCountQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\",\n  });\n\n  // commonjs (aka cjs) doesnt handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return data.account_transactions_aggregate.aggregate ? data.account_transactions_aggregate.aggregate.count : 0;\n}\n\nexport async function getAccountCoinAmount(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  coinId: string;\n}): Promise<number> {\n  const { endlessConfig, accountAddress, coinId } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const { data } = await getAccountCoinsData({\n    endlessConfig,\n    accountAddress: address,\n    options: {\n      where: { coin_id: coinId },\n    },\n  });\n\n  const balance = data[0].balance && data[0].metadata.decimals ?\n    parseInt(data[0].balance, 10) / (10 ** data[0].metadata.decimals) : 0;\n\n  // commonjs (aka cjs) doesnt handle Nullish Coalescing for some reason\n  // might be because of how ts infer the graphql generated scheme type\n  return balance;\n}\n\nexport async function getCoinsDataCreatedBy(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgsOfIndexer & OrderByArg<GetAccountCoinsDataResponse> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetCreatedCoinDataResponse> {\n  const { endlessConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const { data } = await getEndlessIndexer<{}, GetCreatedCoinDataResponse>({\n    endlessConfig,\n    originMethod: \"getCoinsDataCreatedBy\",\n    path: `coins/created_by/${address}`,\n    params: {\n      page: options?.page,\n      pageSize: options?.pageSize,\n      coin: options?.where?.coin_id,\n    }\n  })\n\n  return data\n}\n\nexport async function getAccountCoinsData(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgsOfIndexer & OrderByArg<GetAccountCoinsDataResponse> & WhereArg<CurrentFungibleAssetBalancesBoolExp>;\n}): Promise<GetAccountCoinsDataResponse> {\n  const { endlessConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const { data } = await getEndlessIndexer<{}, GetAccountCoinsDataResponse>({\n    endlessConfig,\n    originMethod: \"getAccountCoinsData\",\n    path: `accounts/${address}/coins`,\n    params: {\n      page: options?.page,\n      pageSize: options?.pageSize,\n      coin: options?.where?.coin_id,\n    }\n  })\n\n  return data;\n}\n\n\nexport async function getAccountCoinsCount(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n}): Promise<number> {\n  const { endlessConfig, accountAddress } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsCountQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\",\n  });\n\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\n\nexport async function getAccountOwnedObjects(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput;\n  options?: PaginationArgs & OrderByArg<GetAccountOwnedObjectsResponse[0]>;\n}): Promise<GetAccountOwnedObjectsResponse> {\n  const { endlessConfig, accountAddress, options } = args;\n  const address = AccountAddress.from(accountAddress).toStringLong();\n\n  const whereCondition: { owner_address: { _eq: string } } = {\n    owner_address: { _eq: address },\n  };\n  const graphqlQuery = {\n    query: GetAccountOwnedObjects,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.offset,\n      limit: options?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetAccountOwnedObjectsQuery>({\n    endlessConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\",\n  });\n\n  return data.current_objects;\n}\n\n/**\n * NOTE: There is a potential issue once unified single signer scheme will be adopted\n * by the community.\n *\n * Becuase on could create 2 accounts with the same private key with this new authenticator type,\n * we’ll need to determine the order in which we lookup the accounts. First unified\n * scheme and then legacy scheme vs first legacy scheme and then unified scheme.\n *\n */\nexport async function deriveAccountFromPrivateKey(args: {\n  endlessConfig: EndlessConfig;\n  privateKey: PrivateKey;\n}): Promise<Account> {\n  const { endlessConfig, privateKey } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    // private key is secp256k1, therefore we know it for sure uses a single signer key\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n    const address = authKey.derivedAddress();\n    return Account.fromPrivateKey({ privateKey, address });\n  }\n\n  if (privateKey instanceof Ed25519PrivateKey) {\n    // lookup single sender ed25519\n    const singleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey,\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: singleSenderTransactionAuthenticatorAuthKey,\n      endlessConfig,\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = singleSenderTransactionAuthenticatorAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: false });\n    }\n    // lookup legacy ed25519\n    const legacyAuthKey = AuthenticationKey.fromPublicKey({\n      publicKey: publicKey.publicKey as Ed25519PublicKey,\n    });\n    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, endlessConfig });\n    if (isLegacyEd25519) {\n      const address = legacyAuthKey.derivedAddress();\n      return Account.fromPrivateKey({ privateKey, address, legacy: true });\n    }\n  }\n  // if we are here, it means we couldn't find an address with an\n  // auth key that matches the provided private key\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\n\nexport async function isAccountExist(args: { endlessConfig: EndlessConfig; authKey: AuthenticationKey }): Promise<boolean> {\n  const { endlessConfig, authKey } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    endlessConfig,\n    authenticationKey: authKey.derivedAddress(),\n  });\n\n  try {\n    await getInfo({\n      endlessConfig,\n      accountAddress,\n    });\n    return true;\n  } catch (error: any) {\n    // account not found\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n\nexport async function getAccountsCoinBalance(args: {\n  endlessConfig: EndlessConfig;\n  accountAddress: AccountAddressInput[];\n  coinAddress: AccountAddressInput;\n}): Promise<GetAccountsCoinBalanceResponse> {\n  const { endlessConfig, accountAddress, coinAddress } = args;\n  const { data } = await postEndlessIndexer<{}, GetAccountsCoinBalanceResponse>({\n    endlessConfig,\n    originMethod: \"getAccountsCoinBalance\",\n    path: `accounts/coins/${coinAddress}`,\n    body: accountAddress\n  })\n  return data;\n}\n"],"mappings":"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","names":["getInfo","args","endlessConfig","accountAddress","data","getEndlessFullNode","AccountAddress","getModules","options","paginateWithCursor","getModule","getModuleInner","memoizeAsync","moduleName","getTransactions","getResources","getResource","resourceType","lookupOriginalAccountAddress","authenticationKey","resource","handle","authKeyAddress","originalAddress","getTableItem","err","EndlessApiError","getAccountTokensCount","whereCondition","queryIndexer","GetAccountTokensCount","getAccountOwnedTokens","graphqlQuery","GetAccountOwnedTokens","getAccountOwnedTokensFromCollectionAddress","collectionAddress","ownerAddress","collAddress","GetAccountOwnedTokensFromCollection","getAccountCollectionsWithOwnedTokens","GetAccountCollectionsWithOwnedTokens","getAccountTransactionsCount","address","GetAccountTransactionsCount","getAccountCoinAmount","coinId","getAccountCoinsData","getCoinsDataCreatedBy","getEndlessIndexer","getAccountCoinsCount","GetAccountCoinsCount","getAccountOwnedObjects","GetAccountOwnedObjects","deriveAccountFromPrivateKey","privateKey","publicKey","AnyPublicKey","Secp256k1PrivateKey","AuthenticationKey","Account","Ed25519PrivateKey","singleSenderTransactionAuthenticatorAuthKey","isAccountExist","legacyAuthKey","authKey","error","getAccountsCoinBalance","coinAddress","postEndlessIndexer"]}