import{a as d}from"./chunk-B4TGWP6T.mjs";import{b as K}from"./chunk-QEQ3A6VM.mjs";import{i as h,l as y,m,o as x}from"./chunk-BVS7ECHS.mjs";import{b as u}from"./chunk-TACUSWEG.mjs";import{e as P,f as g}from"./chunk-DGFOO2VY.mjs";import{b as s}from"./chunk-H24X6T4W.mjs";async function I(o){let{endlessConfig:t,jwt:p,ephemeralKeyPair:e,uidKey:n="sub",derivationPath:i}=o,r={jwt_b64:p,epk:e.getPublicKey().bcsToHex().toStringWithoutPrefix(),exp_date_secs:e.expiryDateSecs,epk_blinder:s.fromHexInput(e.blinder).toStringWithoutPrefix(),uid_key:n,derivation_path:i},{data:c}=await P({endlessConfig:t,path:"fetch",body:r,originMethod:"getPepper",overrides:{WITH_CREDENTIALS:!1}});return s.fromHexInput(c.pepper).toUint8Array()}async function E(o){let{endlessConfig:t,jwt:p,ephemeralKeyPair:e,pepper:n,uidKey:i="sub"}=o;if(s.fromHexInput(n).toUint8Array().length!==d.PEPPER_LENGTH)throw new Error(`Pepper needs to be ${d.PEPPER_LENGTH} bytes`);let r=t.maxExpHorizonSecs??(await x({endlessConfig:t})).maxExpHorizonSecs;if(r<e.expiryDateSecs-K())throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${r}`);let c={jwt_b64:p,epk:e.getPublicKey().bcsToHex().toStringWithoutPrefix(),epk_blinder:s.fromHexInput(e.blinder).toStringWithoutPrefix(),exp_date_secs:e.expiryDateSecs,exp_horizon_secs:r,pepper:s.fromHexInput(n).toStringWithoutPrefix(),uid_key:i},{data:a}=await g({endlessConfig:t,path:"prove",body:c,originMethod:"getProof",overrides:{WITH_CREDENTIALS:!1}}),l=a.proof,f=new y({a:l.a,b:l.b,c:l.c}),b=e.sign(f.hash());return new m({proof:f,nonMalleabilitySignature:b,trainingWheelsSignature:a.training_wheels_signature?u.fromHex(a.training_wheels_signature):void 0,expHorizonSecs:r})}async function A(o){let{jwt:t,uidKey:p,proofFetchCallback:e,pepper:n}=o,i=E({...o}),r=e?i:await i,a=h.fromJwtAndPepper({jwt:t,pepper:n,uidKey:p}).authKey().derivedAddress();return d.create({...o,address:a,proof:r,pepper:n,proofFetchCallback:e})}export{I as a,E as b,A as c};
//# sourceMappingURL=chunk-AWY7CCGK.mjs.map